\documentclass[a4paper,10pt]{article}
\usepackage[american]
           {babel} % needed for iso dates
\usepackage{url}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{array}
\usepackage{underscore}
\usepackage{changepage}   % for the adjustwidth environment

\hypersetup{
  hidelinks
}

\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{color}
\usepackage{textpos}
\usepackage{titling}
\usepackage{titlesec}

\setcounter{secnumdepth}{6}

% From std draft
% We use the 'listings' package, with some small customizations.  The
% most interesting customization: all TeX commands are available
% within comments.  Comments are set in italics, keywords and strings
% don't get special treatment.
% General code style
\lstset{language=C++,
        basicstyle=\small\ttfamily,
        keywordstyle=,
        stringstyle=,
        xleftmargin=1em,
        showstringspaces=false,
        commentstyle=\itshape\rmfamily,
        columns=flexible,
        keepspaces=true,
        texcl=true
}
% end from std draft

\newcommand{\wordingSec}[2]{\vspace{15pt}
\noindent
{\large\textbf{X.Y\quad #1\hfill\textbf{[#2]}}}
}

% Counters
\newcounter{countWordingSubSec}
\newcounter{countWordingSubSubSec}[countWordingSubSec]

\renewcommand{\thecountWordingSubSec}{X.Y.\arabic{countWordingSubSec}}
\renewcommand{\thecountWordingSubSubSec}{X.Y.\arabic{countWordingSubSec}.\arabic{countWordingSubSubSec}}

% Defs of sub and subsub section (for the wording).
\newcommand{\wordingSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSec}
\noindent
{\textbf{\thecountWordingSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\wordingSubSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSubSec}
\noindent
{\textbf{\thecountWordingSubSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\cpp}[1]{\lstinline{#1}}

\newcommand{\todo}[1]{\emph{\textcolor{red}{TODO: #1}}}

% Wording items
\newcommand{\wordingItem}[1]{\noindent\textit{#1:}}

\newenvironment{wordingTextItem}[1]{\wordingItem{#1}\vspace{7pt}\noindent\begin{adjustwidth}{12pt}{}}{\vspace{7pt}\end{adjustwidth}}

\newenvironment{wordingNoteItem}{[\wordingItem{Note}}{---\textit{end note}]}

\newenvironment{wordingPara}{\begin{adjustwidth}{12pt}{}}{\end{adjustwidth}}

\lstset{
  xleftmargin=12pt
}

\setlength{\droptitle}{10em}
\title{A proposal to add a utility class to represent expected monad}
\author{}
\date{}

\begin{document}

\maketitle
\begin{textblock*}{9cm}(7cm,-8cm)
\begin{tabular}{l l}
\textbf{Document number:} & Dxxxx=xx-xxxx \\
\textbf{Date:}  & \today \\
\textbf{Revises:} & None \\
\textbf{Project:} & JTC1.22.32 Programming \\
 & Language C++ \\
\textbf{Reply to:} & Vicente J. Botet Escriba \\
 & <\href{mailto:vicente.botet@wanadoo.fr}{vicente.botet@wanadoo.fr}> \\
 & Pierre Talbot <\href{mailto:ptalbot@hyc.io}{ptalbot@hyc.io}>
\end{tabular}
\end{textblock*}

\vspace{-6em}
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}
%%%%%%%%%%%

Class template \cpp{expected<T,E>} proposed here is a type that may contain a value of type \cpp{T} or a value of type \cpp{E} in its storage space. \cpp{T} represents the expected value, \cpp{E} represents the reason explaining why it doesn't contains a value of type \cpp{T}, that is the unexpected value. Its interface allows to query if the underlying value is either the expected value (of type \cpp{T}) or an unexpected value (of type \cpp{E}). The original idea comes from Andrei Alexandrescu C++ and Beyond 2012: Systematic Error Handling in C++ talk \cite{AlexandrescuExpected}. The interface is based on \cpp{std::optional} N3793 \cite{OptionalRev5} and Haskell monads. It requires no changes to core language, and breaks no existing code.

\section{Motivation and Scope}
%%%%%%%%%%%%%%%%

Basically, the two main error mechanisms are exceptions and return codes. Before further explanation, we should ask us what are the characteristics of a good error mechanism.

\begin{itemize}
 \item \textbf{Error visibility} Failure cases should appears throughout the code review. Because the debug can be painful if the errors are hidden.
 \item \textbf{Information on errors} The errors should carry out as most as possible information from their origin, causes and possibly the ways to resolve it.
 \item \textbf{Clean code} The treatment of errors should be in a separate layer of code and as much invisible as possible. So the code reader could notice the presence of exceptional cases without stop his reading.
 \item \textbf{Non-Intrusive error} The errors should not monopolize a communication channel dedicated to the normal code flow. They must be as discrete as possible. For instance, the return of a function is a channel that should not be exclusively reserved for errors.
\end{itemize}

The first and the third characteristic seem to be quite contradictory and deserve further explanation. The former points out that errors not handled should appear clearly in the code. The latter tells us that the error handling mustn't interfere with the code reading, meaning that it clearly shows the normal execution flow. A comparison between the exception and return codes is given in the table \ref{comp-handling-error}.


\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
                    & \textbf{Exception} & \textbf{Return code} \\
\hline
\textbf{Visibility} & Not visible without further analysis of the code. However, if an exception is thrown, we can follow the stack trace. & Visible at the first sight by watching the prototype of the called function. However ignoring return code can lead to undefined results and it can be hard to figure out the problem. \\
\hline
\textbf{Informations} & Exceptions can be arbitrarily rich. & Historically a simple integer. Nowadays, the header \cpp{<system_error>} provides richer error code. \\
\hline
\textbf{Clean code} & Provides clean code, exceptions can be completely invisible for the caller. & Force you to add, at least, a if statement after each function call. \\
\hline
\textbf{Non-Intrusive} & Proper communication channel. & Monopolization of the return channel. \\
\hline
\end{tabular}
\egroup
\caption{Comparison between two error handling systems.}
\label{comp-handling-error}
\end{table}

\subsection{Alexandrescu Expected class}
%%%%%%%%%%%%%%%%%%%%

We can do the same analysis for the \cpp{Expected<T>} class from Alexandrescu talk \cite{AlexandrescuExpected}:

\begin{itemize}
 \item \textbf{Error visibility} It takes the best of the exception and error code. It's visible because the return type is Expected<T> and if the user ignore the error case, it throws the contained exception.
 \item \textbf{Information} As rich as exception.
 \item \textbf{Clean code} It's up to the programmer to choose handling errors as error code or to throw the contained exception.
 \item \textbf{Non-Intrusive} Use the return channel without monopolizing it.
\end{itemize}

\noindent
Other characteristics of \cpp{Expected<T>}:

\begin{itemize}
 \item Associates errors with computational goals.
 \item Naturally allows multiple exceptions inflight.
 \item Switch between ``error handling'' and ``exception throwing'' styles.
 \item Teleportation possible.
 \begin{itemize}
  \item Across thread boundaries.
  \item Across nothrow subsystem boundaries.
  \item Across time: save now, throw later.
 \end{itemize}
 \item Collect, group, combine exceptions.
\end{itemize}

\noindent
However \cpp{Expected<T>} class also has some minor limitations:
\begin{itemize}
 \item The error code must be an exception.
 \item It doesn't provide a better solution to resolve errors. You can throw or use the \cpp{hasException<E>()} function to test errors which is similar to the old switch case statement.
 \item The function \cpp{hasException<E>()} test the type and so cannot distinguish two different errors from the same exception. Exception can contains multiple error case scenarios (think about \cpp{std::invalid_argument}).
\end{itemize}

\subsection{Differences between the proposed expected class and Alexandrescu Expected class}

The main enhancements or differences of the proposed \cpp{expected<T,E>} respect to \cpp{Expected<T>} are:
\begin{itemize}
 \item \cpp{expected<T,E>} parameterizes the root cause that prevents its creation, \cpp{expected<T,E>} is either a \cpp{T} or the root cause \cpp{E} that prevents its creation. The default type \cpp{E} would be \cpp{std::exception_ptr} as the exceptions seem to be the most used error-handling system. There is also some supports for the classes in the \cpp{<system_error>} header.
 \item \cpp{expected<T,E>} is default constructible.
 \item \cpp{expected<T,E>} is a monad (see \cite{MONAD}).
\end{itemize}

\section{Use cases}
%%%%%%%%%%

\subsection{Safe division}
%%%%%%%%%%%

Using exceptions, we can define a version of integer division that checks for divide-by-zero conditions, we might write something like this:

\begin{lstlisting}
struct DivideByZero: public std::exception {...};

int safe_divide(int i, int j)
{
  if (j==0) throw (DivideByZero());
  else return i/j;
}
\end{lstlisting}

\noindent
Using \cpp{expected<int>}

\begin{lstlisting}
expected<int> safe_divide(int i, int j)
{
  if (j==0) return make_unexpected(DivideByZero()); // (1)
  else return i / j; // (2)
}
\end{lstlisting}

(1) uses un implicit conversion from unexpected<E> to expected<T,E>. 

(2) uses un implicit conversion from T to expected<T,E>.

The advantages are that we have a clean way to say that a function has failed without using the exception machinery, and we can give precise information about why it failed as well. The liability is that this function is going to be tedious to use. For instance, the exception based function:

\begin{lstlisting}
int f1(int i, int j, int k)
{
  return i+ safe_divide(j,k);
}
\end{lstlisting}

becomes using expected<int> 

\begin{lstlisting}
expected<int> ex_f1(int i, int j, int k)
{
  auto q2 = safe_divide(j, k);
  if (! q2.valid()) return q2.get_unexpected(); // (1)
  return i + q2.get_value(); // (2)
}
\end{lstlisting}

(1) When safe_divide fails we forward the unexpected value.

(2) Here we know that q2 has a valid value.

This is pretty complicated considering what we are trying to do. In addition, the return type expected<int> is different from the input types (which are all ints), so it's going to be hard to compose functions which return these \cpp{expected<>} values with functions that don't. But let's press on for now and deal with those problems later.

We can use \cpp{expectd<T>} to represent different error conditions. For instance, with integer division, we might want to fail if the two numbers are not evenly divisible as well as checking for division by zero. We can improve our safe_divide function accordingly:

\begin{lstlisting}
struct NotDivisible: public std::exception
{
  int i, j;
  NotDivisible(int i, int j) : i(i), j(j) {}
};

expected<int> safe_divide(int i, int j)
{
  if (j == 0) return make_unexpected(DivideByZero()); 
  if (i%j != 0) return make_unexpected(NotDivisible(i,j));
  else return i / j; 
}
\end{lstlisting}

Now we have a division function for integers that can handle two error conditions. However, it's not easy to write code which detects which of the two conditions occurred. For instance, we might have situations where dividing two integers which are not evenly divisible is OK (we just throw away the remainder) but division by zero is probably never going to be OK. Let's try to write this using our safe_divide function, first using exceptions


\begin{lstlisting}
T divide(T i, T j)
{
  try
  {
    return safe_divide(i,j)
  }
  catch(NotDivisible& ex)
  {
    return ex.i/ex.j;
  }
  catch(...)
  {
    throw;
  }
}
\end{lstlisting}

and then using \cpp{expect<>}

\begin{lstlisting}
boost::expected<int> divide(int i, int j)
{
  auto r =  safe_divide(i,j);
  if (r.has_exception<NotDivisible>()) return i / j;
  return  r;
}
\end{lstlisting}


Lets continue with this very simple function on integers:

\begin{lstlisting}
int f2(int i, int j, int k)
{
  return safe_divide(i,k) + safe_divide(j,k);
}
\end{lstlisting}

Before I show you the expected<> version of this function, I want to rewrite the function f slightly:


\begin{lstlisting}
int f2(int i, int j, int k)
{
  auto s1 = safe_divide(i,k);
  auto s2 = safe_divide(j,k);
  return s1 + s2;
}
\end{lstlisting}


Now let's write this code using an expected<int> type. We get this:

\begin{lstlisting}
boost::expected<int> f2(int i, int j, int k)
{
  auto eq1 = safe_divide(i, k);
  if (!eq1.valid()) return eq1.get_unexpected();
  auto q1 = *eq1;

  auto eq2 = safe_divide(j, k);
  if (!eq2.valid()) return eq2.get_unexpected();
  auto q2 = *eq2;

  return q1 + q2;
}
\end{lstlisting}

This is nice in the sense that whenever there is an error (as we have defined it) we get a specific error result. Now let's rewrite this using a possible C++ language extension:
adding a expect operator, something similar to the await extension for futures.  The meaning of expect expr is:

\begin{itemize}
 \item if the expected expr is not valid return with its unexpected value,
 \item otherwise store the value for further evaluation.
\end{itemize}

\begin{lstlisting}
boost::expected<int> g2(int i, int j, int k)
{
  return expect safe_divide(i,k) + expect safe_divide(j,k);
}
\end{lstlisting}

or 

\begin{lstlisting}
boost::expected<int> g2(int i, int j, int k)
{
  auto q1 = expect safe_divide(i,k);
  auto q2 = expect safe_divide(j,k);
  return q1 + q2;
}
\end{lstlisting}

This would give the exact same results as the previous version. However, the function \cpp{g2} is much simpler and clearer than \cpp{f2} because it doesn't have to explicitly handle any of the error cases. When an error case occurs, it is returned as the result of the function, but if not, the correct result of a subexpression is bound to a name (q1 or q2), and that result can be used in later parts of the computation. The code is a lot simpler to write. The more complicated the error-handling function, the more important this will be.

But, we don't have this except extension yet. We can rewrite this without using the expect-extension and using a continuation passing style as follows:

\begin{lstlisting}
boost::expected<int> f(int i, int j, int k)
{
  return safe_divide(i, k).then([=](int q1)    {
      return safe_divide(j,k).then([=](int q2)  {
        return q1+q2;
      });
    });
}
\end{lstlisting}

We can also compose all the expected values using the when_all function.

\begin{lstlisting}
boost::expected<int> f(int i, int j, int k)
{
  return when_all(safe_divide(i, k), safe_divide(j,k)).then(add);
}
\end{lstlisting}


Waiting for a expect-extension the user could define a macro

\begin{lstlisting}
#define EXPECT(V, EXPR) \
auto BOOST_JOIN(expected,V) = EXPR; \
if (! BOOST_JOIN(expected,V).valid()) return BOOST_JOIN(expected,V).get_unexpected(); \
auto V =*BOOST_JOIN(expected,V)
\end{lstlisting}

and define f as

\begin{lstlisting}
boost::expected<int> f(int i, int j, int k)
{
  EXPECT(q1, safe_divide(i,k));
  EXPECT(q2, safe_divide(j,k));
  return q1 + q2;
}
\end{lstlisting}

Alternatively, if the \cpp{operator+} is defined for \cpp{expected<int>}

\begin{lstlisting}
template <class T>
expected<T> operator+(expected<T> i, expected<T> j)
{
  EXPECT(i_, i);
  EXPECT(j_, j);
  return i_ + j_;
}
\end{lstlisting}

the function f2 could be defined as

\begin{lstlisting}
boost::expected<int> f2(int i, int j, int k)
{
  return safe_divide(i, k) + safe_divide(j, k);
}
\end{lstlisting}

which is the cleaner we can get at the expenses of defining the \cpp{operator+}.


\subsection{Parse int}
%%%%%%%%%%%

\begin{lstlisting}
  expected<int> parseInt(const std::string& s) {
    int result;
    //...
    if (nonDigit)  
      return make_unexpected(std::invalid_argument("not a number"));
    //...
    if (tooManyDigits) 
      return make_unexpected(std::out_of_range("overflow"));
    //...
    return make_expected(result);
  }

  // Caller
  std::string s = readline();
  auto x = parseInt(s).value(); // throw on error
  auto y = parseInt(s); // won't throw
  if (!y.valid()) {
    // handle locally
    if (y.has_exception<std::invalid_argument>()) {
      // no digits
      //...
    }
    y.value(); // just "re"throw the stored exception
  }
\end{lstlisting}

Next follows the \cpp{parseInt} function using a specific error.

\begin{lstlisting}
  expected<int, myerrc> parseInt(const std::string& s)  {
    int result;
    //...
    if (nonDigit)  
      return make_unexpected(myerrc::non_digit);
    //...
    if (tooManyDigits)  
      return make_unexpected(myerrc::overflow);
    //...
    return make_expected(result);
  }

  // Caller
  std::string s = readline();
  auto x = parseInt(s).value(); // throws bad_exected_access(y.error()) on error
  auto y = parseInt(s); // won't throw
  if (!y.valid()) {
    // handle locally
    if (y.error() == std::errc::invalid_argument)  {
      // no digits
      //...
    }
    y.value(); // just throws bad_exected_access(y.error())
  }
\end{lstlisting}

\subsection{Getting an int range}
%%%%%%%%%%%%%%

The next use case show how expected scales and compose. 

Given a function that gets an int \cpp{getInt} and one that matches a string \cpp{matchesString}, how to define a function that parses an int range"<int>..<int>" \cpp{getIntRange}

Next follows the Standard IO facet style to get an int from a stream (only the iterators are show)

\begin{lstlisting}
template <typename InputIterator>
  InputIterator getInt(InputIterator s, InputIterator end, errc& err, int& t);
\end{lstlisting}

In addition to manage with the Iterators, the function changes the error and the int value itself. Let me start by defining the function as if the functions throw an exception when there is an error. Moving to a pure functional style gives.

\begin{lstlisting}
template <typename InputIterator>
  pair<InputIterator, int> getInt(InputIterator s, InputIterator end);
template <typename InputIterator>
  pair<InputIterator, bool> matchesString(string, InputIterator s, InputIterator end);
\end{lstlisting}

The get int range could be defined as

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, pair<int,int>> getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s,e);
    auto m = matchesString("..", f.first, e).
    auto l = getInt(m.first,e);       
    return make_pair(l.first, make_pair(f.second, l.second));
}
\end{lstlisting}

Clearly this is quite clean. However, when exceptions are not desirable, \cpp{expected<>} comes into play. 
The signature of \cpp{getInt} using \cpp{expected}, could be either

\begin{lstlisting}
template <class InputIterator, class Num>
  pair<InputIterator, expected<int, errc> get(InputIterator s, InputIterator e);
\end{lstlisting}

or 

\begin{lstlisting}
template <class InputIterator, class Num>
  expected<pair<InputIterator, int>, pair<InputIterator, errc> > get(InputIterator s, InputIterator e);
\end{lstlisting}

Next we analyze both possibilities and conclude which approach is better adapted.

\subsubsection{Returning pair}
%%%%%%%%%%%%%%%%

So given the following prototypes:

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, expected<int>> getInt(InputIterator s, InputIterator e);
template <class InputIterator>
  pair<InputIterator, expected<void>> matchesString(std::string, InputIterator s, InputIterator e);
\end{lstlisting}

\noindent
how to define a function

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, expected<pair<int,int>>> getIntRange(InputIterator s, InputIterator e);
\end{lstlisting}


One solution consists in checking if there is an error at every step. 

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, expected<pair<int,int>>> 
  getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s, e);
    if (! f.second.valid())  return make_pair(f.first, expected<pair<int,int>>::from_error(f.error()));
    auto m = matchesString(":", s, e).
    if (! m.valid())  return make_pair(m.first, expected<pair<int,int>>::from_error(m.error()));
    auto l = getInt(s, e);
    if (! l.valid())  return make_pair(l.first, expected<pair<int,int>>::from_error(l.error()));
        
    return make_pair(l.first, make_expected(make_pair(f.value(), l.value())));
}
\end{lstlisting}

The preceding approach contains too much noise respect to the exception based solution. An alternative is a continuation passing style. 

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, expected<pair<int,int>>> getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s, e);
    return f | [e](std::pair<InputIterator,int> f) {
    	       return matchesString("..", f.first, e); 
	  }  | [e](std::pair<InputIterator,int> m) {
               return getInt(m.first, e); 
	  }  | [f](std::pair<InputIterator,int> l) {
               return make_pair(l.first, make_expected(make_pair(*f.second, l.second))); 
	  };
}
\end{lstlisting}

Note that the control flow has disappeared but the calls have been wrapped on some lambda expressions. Let me analyze what is behind the scenes. The main point is the definition of the operator|(). 

\begin{lstlisting}
template <class T, class I, typename E, class F>
typename std::result_of<F(value_type)>::type type
operator|(pair_expected<T, I, E> m, F f) {
    typedef typename std::result_of<F(value_type)>::type result_type;
    typedef typename result_type::second_type expected_type;
    if (m.second.valid()) {
      return f(std::make_pair(m.first, m.second.value()));
    }
    return make_pair(m.first, expected_type(m.second.get_unexpected()));
}
\end{lstlisting}

If N3559 - Generic (Polymorphic) Lambda Expressions is accepted, the code could be written as

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, expected<pair<int,int>>> getIntRange(InputIterator s, InputIterator e) {
    auto f =                        getInt(s, e);
    return f | [e](auto f) { return matchesString("..", f.first, e); 
	  }  | [e](auto m) { return getInt(m.first, e); 
	  }  | [f](auto l) { return make_pair(l.first, make_expected(make_pair(*f.second, l.second))); 
	  };
}
\end{lstlisting}

which is quite close to the exception based solution

\begin{lstlisting}
template <class InputIterator>
  pair<InputIterator, pair<int,errc>> getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s,e);
    auto m = matchesString("..", f.first, e).
    auto l = getInt(m.first,e);       
    return make_pair(l.first, make_expected(make_pair(f.second, l.second)));
}
\end{lstlisting}

\subsubsection{Returning expected}
%%%%%%%%%%%%%%%%%%%

So given the following prototypes:

\begin{lstlisting}
template <class InputIterator>
  expected<pair<InputIterator, int>, pair<InputIterator, errc> > get(InputIterator s, InputIterator e);
template <class InputIterator>
  expected<InputIterator, pair<InputIterator, errc> > matchesString(InputIterator s, InputIterator e);
\end{lstlisting}

\noindent
how to define a function

\begin{lstlisting}
template <class InputIterator, class Num>
  expected<pair<InputIterator, pair<int, int>, pair<InputIterator, errc> > 
  get(InputIterator s, InputIterator e);
\end{lstlisting}

One solution consists in checking if there is an error at every step. 

\begin{lstlisting}
template <class InputIterator>
  expected<pair<InputIterator, pair<int, int>, pair<InputIterator, errc> > 
  getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s, e);
    if (! f.valid())  return f.get_unexpected();
    auto m = matchesString(":", f->first, e).
    if (! m.valid()) return m.get_unexpected();
    auto l = getInt(*m, e);
    if (! l.valid()) return l.get_unexpected();
        
    return make_pair(l->first, make_pair(f->second, l->second);
}
\end{lstlisting}

The preceding approach contains too much noise respect to the exception based solution. An alternative is a continuation passing style. 

\begin{lstlisting}
template <class InputIterator>
  expected<pair<InputIterator, pair<int, int>, pair<InputIterator, errc> > 
  getIntRange(InputIterator s, InputIterator e) {
    auto f = getInt(s, e);
    return f | [e](std::pair<InputIterator,int> f) {
    	       return matchesString("..", f.first, e); 
	  }  | [e](InputIterator m) {
               return getInt(m, e); 
	  }  | [f](std::pair<InputIterator,int> l) {
               return make_pair(l.first, make_pair(f->second, l.second)); 
	  };
}
\end{lstlisting}


\subsection{\todo{Title needed}}
%%%%%%%%%%%%%%%%

We should wonder what every programmers do when a function call returns an error:

\begin{enumerate}
 \item Nothing.
 \item Delegate the responsibility of error handling to higher layer.
 \item Trying to resolve the error.
\end{enumerate}

Because the first behavior leads to buggy application, we won't consider it in a first time. Consider the following ``pseudo coded'' mock function:

\begin{lstlisting}
EXPECTED int mock_connect(const string& hostname, const string& passwd, bool timed_out){
  if(passwd != "passwd")
      return connection refused ERROR
  else if(hostname != "localhost")
      return host unreachable ERROR
  else if(timed_out)
      return timed out ERROR
  return HANDLE 0
}
\end{lstlisting}

We imagine a scenario where:

\begin{itemize}
 \item The \textit{connection refused} error is resolved by asking the user another password.
 \item The \textit{host unreachable} error is delegated to the upper layer.
 \item The \textit{time out} error is resolved at the next try.
\end{itemize}

\subsection{Exception-based expected}
%%%%%%%%%%%%%%%%%%%%

The code of the mock connect function is below. You can see that the errors are encapsulated into exceptions.
\begin{lstlisting}
expected<int> mock_connect(
    const std::string& hostname, 
    const std::string& passwd, 
    bool timed_out) {
  if(passwd != "passwd")
      return expected<int>::from_error(connection_refused());
      //return make_expected_from_error<int>(connection_refused());
  else if(hostname != "localhost")
      return expected<int>::from_error(host_unreachable());
      //return make_expected_from_error<int>(host_unreachable());
  else if(timed_out)
      return expected<int>::from_error(timeout());
      return make_expected_from_error<int>(timeout());
  return expected<int>(0);
}
\end{lstlisting}

From the caller, the code looks like:

\begin{lstlisting}
expected<int> connect_to_host(const std::string& host){
  return mock_connect(host, ask_password(host), true)
  .recover([](exception_ptr except){
    bool timed_out = true;
    expected<int> handle;
    do { 
      try {  
        if (!valid) std::rethrow_exception(except);
      } catch (const connection_refused& ex) {
        std::cout << "Wrong password ?" << std::endl;
        handle = mock_connect(host, ask_password(host), timed_out);
      } catch (const timeout& ex) {
        std::cout << "Error: timed out. Try again." << std::endl;
        timed_out = false;
        handle = mock_connect(host, ask_password(host), timed_out);
      } catch (...) {
        // Delegate responsibility to higher layer.
        return make_expected<int>(except);      
      }
    } while(!handle.valid());
    return handle;
  }).then([](int value){
    std::cout << "handle no: " << value << std::endl;
  });
}
\end{lstlisting}

Note the error resolver function to keep the code as clean as possible.

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

The next section shows how to do the same things with the standard error code (\cpp{std::error_condition}).

\subsection{Error-based expected}
%%%%%%%%%%%%%%%%%%

We use the class \cpp{expected_or_error} which looks like the class expected without the exception.

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

From the caller, the code looks like:

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

And finally the error resolver:

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

We can see that the code is quite similar between both classes. It's mainly because we didn't use the exception facility of the expected class.

\subsection{Result}
%%%%%%%%%%

The result of the both codes is the same 

\begin{lstlisting}
TODO INSERT CODE
\end{lstlisting}

\section{Impacts on the Standard}
%%%%%%%%%%%%%%%%%

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++ 14. It requires however the \cpp{in_place_t} from N3793.

\section{Design rationale}
%%%%%%%%%%%%%


\subsection{Never-empty guaranty}
%%%%%%%%%%%%%%%%%%

As \cpp{boost::variant}, \cpp{expected<T,E>} ensures that it is never empty.
All instances \cpp{v} of type \cpp{expected<T,E>} guarantee that \cpp{v} has constructed content of one of the types \cpp{T} or \cpp{E}, even if an operation on \cpp{v} has previously failed.

This implies that expected may be viewed precisely as a union of exactly its bounded types. This "never-empty" property insulates the user from the possibility of undefined expected content and the significant additional complexity-of-use attendant with such a possibility.

\subsection{\cpp{expected<T, E>} is default constructible if \cpp{T} is default constructible}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cpp{expected<T,E>} should behave as much as possible as \cpp{T}. 

\subsection{Making \cpp{expected<T,E>} default constructible}
It is possible to make it default constructible adding an additional \cpp{init} \cpp{bool} member, but this is in some way equivalent to have \cpp{optional<expected<T,E>>}, so this proposal doesn't propose default constructor for any \cpp{T}.

\subsection{Observers}
%%%%%%%%%%%%


\subsection{Monad}
%%%%%%%%%%


\section{Related work}
%%%%%%%%%%%

\subsection{Either monad and Variant}
%%%%%%%%%%%%%%%%%%%%

\cpp{expected<T,E>} can be seen as a specialization of a possible \cpp{either<T,E>} or \cpp{boost::variant<T,E>} which gives a specific intent to its first parameter, that is, it represent the type of the expected contained value. This specificity allows to provide a pointer like interface, as it is the case for \cpp{std::experimental::optional<T>}. Even if the standard contained a class \cpp{either<T,E>} or \cpp{variant<T,E>}, the interface provided by expected<T,E> is more specific and closer to what the user could expect as the result type of a function. In addition, \cpp{expected<T,E>} doesn't intend to be used to define recursive data as \cpp{boost::variant<>} does.

\subsection{Optional}
%%%%%%%%%%%

We can see \cpp{expected<T,E>} as an optional that collapse all the values of \cpp{E} to \cpp{nullopt}. We can convert an \cpp{expected<T, E>} to an \cpp{optional<T>} with the possible loss of information.

\begin{lstlisting}
template <class T>
optional<T> optionalCast(expected<T,E> v) {
  if (v.valid()) return make_optional(*v);
  else nullopt;
}
\end{lstlisting}

We can convert an \cpp{optional<T>} to an \cpp{expected<T>} with the possible loss of the root cause.

\begin{lstlisting}
template <class T>
expected<T> expectedCast(optional<T>) {
  if (v.valid()) return make_expected(*v);
  else expected<T>::from_error();
}
\end{lstlisting}

\subsection{Promise and Future}
%%%%%%%%%%%%%%%%%

We can see \cpp{expected<T>} as an immediate \cpp{future<T>}.
While \cpp{promise<>}/\cpp{future<>} focuses on inter-thread asynchronous communication, \cpp{excepted<>} focus on eager and synchronous computations.
We can move a ready \cpp{future<T>} to an \cpp{expected<T>} with no loss of information. At the end, the underlying type of \cpp{future<T>} could be \cpp{shared_ptr<expected<T>>}.

\begin{lstlisting}
template <class T>
expected<T> expectedCast(future<T>&& f) {
  assert (f.ready() && "future not ready");
  if (! f.valid()) 
    return expected<T>::from_error(getExceptionPtr(f)); // (1)
  else 
    return make_expected(f.value());
}
\end{lstlisting}

Remark: in line (1) we could use instead \cpp{std::future<T>::get_exception_ptr()}, which is now provided by Boost.Thread, that can be implemented by the library more efficiently than the user could do.

We can combine them as follows

\begin{lstlisting}
fut.then([](future<int> f) { return expectedCast(f).
	then([](i){ ... }).recover(...);}
\end{lstlisting}

We can create also a \cpp{future<T>} from an \cpp{expected<T>}.

\begin{lstlisting}
template <class T>
future<T> make_ready_future(expected<T>&& e) {
  if (e.valid()) 
    return make_ready_future(e.value();
  else 
    return make_exceptional_future(f.error()); // (2)
}
\end{lstlisting}

Remark: line (2) uses Boost.Thread provides

\begin{lstlisting}
future<T> make_exceptional_future(exception_ptr ex);
\end{lstlisting}


\subsection{Expected monad}
%%%%%%%%%%%%%%%

As for the \cpp{future<T>} proposal, \cpp{expected<T,E>} provides also a way to visit the stored values.
\cpp{future<T>} provides a \cpp{then()} function that accepts a continuation having the \cpp{future<T>} as parameter. The synchronous nature of expected makes it more appropriated to use two functions, one to manage with the case expected has a value and one to try to recover otherwise. This is more in line with the monad interface, as any function having a \cpp{T} as parameter can be used as parameter of the apply function, no need to have a \cpp{expected<T>}. This make it easier to reuse functions. 

\begin{itemize}
 \item \cpp{expected<T,E>::next()}/\cpp{expected<T,E>::recover()} are the counterpart of \cpp{future<T>.then()}
 \item \cpp{expected<T,E>::unwrap()} is the counterpart of \cpp{future<T>.unwrap()}
 \item \cpp{expected<T,E>::valid()} is the counterpart of \cpp{future<T>.has_value()}
 \item \cpp{expected<T,E>::if_all()} and \cpp{expected<T,E>::if_any()} are the counterpart of \cpp{when_all()} and \cpp{when_any()}
\end{itemize}

\subsection{Comparison between optional, expected and future}

The table \ref{comp-monads} presents a brief comparison between \cpp{optional<T>}, \cpp{expected<T>}  and \cpp{promise<T>/future<T>}.

\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|}
\hline
                    & \textbf{optional} & \textbf{expected} & \textbf{promise/future} \\
\hline
\textbf{specific null value} & yes & no & no \\
\hline
\textbf{relational operators} & yes & yes & no \\
\hline
\textbf{swap} & yes & yes & yes \\
\hline
\textbf{factories} & make_optional / nullopt & make_expected / make_expected_from_call / make_expected_from_error & make_ready_future / (make_expected_from_error, see \cite{MoreAsync}) \\
\hline
\textbf{hash} & yes & yes & yes \\
\hline
\textbf{value_type} & yes & yes & no / (yes, see \cite{MoreAsync}).  \\
\hline
\textbf{default constructor} & yes & yes (if T is default constructible) & yes \\
\hline
\textbf{allocators} & no & no & yes \\
\hline
\textbf{emplace} & yes & yes & no \\
\hline
\textbf{bool conversion} & yes & yes & no \\
\hline
\textbf{state} & bool()  & valid / bool() & valid / ready / (has_value, see \cite{MoreAsync}) \\
\hline
\textbf{observers} & pointer-like / value / value_or & pointer-like / value / error / value_or / value_or_throw & get / (get_exception_ptr, see \cite{MoreAsync}) \\
\hline
\textbf{continuations} & no & then/next/recover / if_all / if_any & then/ when_all / when_any / (next/recover see \cite{MoreAsync}) \\
\hline
\end{tabular}
\egroup
\caption{Comparison between optional, expected and promise/future.}
\label{comp-monads}
\end{table}



\section{Open questions}
%%%%%%%%%%%%%

\subsection{Allocator support}
%%%%%%%%%%%%%%%

As \cpp{optional<T>},  \cpp{expected<T,E>} does not allocate memory. So it can do without allocators. However, it can be useful in compound types like:

\begin{lstlisting}
typedef vector< expected<vector<int, MyAlloc>>, MyAlloc>; MyVec;
MyVec v{ v2, MyAlloc{} };
\end{lstlisting}

One could expect that the allocator argument is forwarded in this constructor call to the nested vectors that use the same allocator. Allocator support would enable this. \cpp{std::tuple} offers this functionality.

\subsection{Which exception throw when the user try to get the expected value but there is none?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested to let the user decide the Exception, that would be throw when the user try to get the expected value but there is none, as third parameter. 

While there is no major complexity doing it, as it just needs a third parameter that could default to the appropriated class, 

\begin{lstlisting}
template <class T, class Error, class Exception = bad_expected_access>
  struct expected;
\end{lstlisting}

the authors consider that this is not really needed and that this parameter should not really be part of the type.

The user can use \cpp{value_or_throw()} as

\begin{lstlisting}
std::expected<int, std::error_code> f();
std::expected<int, std::error_code> expect = f();
auto i = expct.value_or_throw<std::system_error>();  
\end{lstlisting}

The user can also wrap the proposed class in its own expected class

\begin{lstlisting}
template <class T, class Error=std::error_code, class Exception=std::system_error>
struct MyExpected {
  expected <T,E> v;
  MyExpected(expected <T,E> v) : v(v) {}
  T value() {  
    if (e.valid()) return v.value();
    else throw Exception(v.error());
  }
  ...
};
\end{lstlisting}

and use it as

\begin{lstlisting}
std::expected<int, std::error_code> f();
MyExpected<int> expect = f();
auto i = expct.value();  // std::system_error throw if not valid
\end{lstlisting}

A class like this one could be added to the standard, but this proposal doesn't request it. 

\subsection{About expected<T, ErrorCode, Exception>}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested also to extend the design into something that contains 

\begin{itemize}
\item a T, or
\item an exception_ptr, or 
\item an error_code
\end{itemize}

Again there is no major difficulty to implement it, but instead of having one variation point we have two, that is, is there a value, and if not, if is there an exception_ptr. While this would need only an extra test on the exceptional case, the authors think that it is not worth doing it as all the copy/move/swap operations would be less efficient.  

\begin{lstlisting}
template <class T, class ErrorCode = none, class Exception = expected_default_exception<ErrorCode>>
  struct expected;
\end{lstlisting}

\section{Proposed Wording}
%%%%%%%%%%%%%%


The proposed changes are expressed as edits to N3797, the C++ Draft Standard \cite{Cppdraft}. The wording has been adapted from N3797 \cite{OptionalRev5}.
\newline

Insert a new section.

\wordingSec{Expected library}{expected}
%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{In general}{expected.general}
%%%%%%%%%%%%%%%%%%%%%%%%

This subclause describes class template expected that represents expected objects. An expected object for object type T is an object that contains the storage for another object and manages the lifetime of this contained object T, alternatively it could contain the storage for another unexpected object E. The contained object may not be initialized after the expected object has been initialized, and may not be destroyed before the expected object has been destroyed. The initialization state of the contained object is tracked by the expected object.

\wordingSubSec{Header <experimental/expected> synopsis}{expected.synop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {namespace experimental {

  // \ref{expected.object}, expected for object types  
  template <class T, class E = exception_ptr>
  class expected;
  template <class E>
  class expected<void, E>;
  
  // \ref{expected.unexpected}, unexpected object type
  template <class E>
  struct unexpected{};
   
  // \ref{expected.bad_expected_access}, class bad_expected_access
  class bad_expected_access;
  
  // \ref{expected.relational_op}, Relational operators
  template <class T>
    constexpr bool operator==(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator!=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>=(const expected<T, E>&, const expected<T, E>&);
    
  // \ref{expected.comparison_T}, Comparison with T
  template <class T> constexpr bool operator==(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator==(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator!=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator!=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>=(const T&, const expected<T, E>&);

  // \ref{expected.specalg}, Specialized algorithms
  template <class T> 
    void swap(expected<T, E>&, expected<T, E>&) noexcept(see below);

  // \ref{expected.factories}, Factories
  template <class T> constexpr expected<see below> make_expected(T&& v);
  template <> constexpr expected<void> make_expected(); 
  template <class T>
   constexpr expected<T> make_expected_from_error(std::exception_ptr v); 
  template <class T, class E>
   constexpr expected<T> make_expected_from_error(E&& v);
  template <class T>
   constexpr expected<T> make_expected_from_error(); 
  template <class F>
   constexpr typename expected<typename result_type<F>::type
   make_expected_from_call(F f);

  // \ref{expected.hash}, hash support
  template <class T> struct hash;
  template <class T> struct hash<expected<T, E>>;
}}
\end{lstlisting}

\wordingSubSec{Definitions}{expected.defs}
%%%%%%%%%%%%%%%%%%%%%%

An instance of \cpp{expected<T,E>} is said to be valued if it contains an object of type \cpp{T}.
An instance of \cpp{expected<T,E>} is said to be unexpected if it contains an object of type \cpp{E}.

\wordingSubSec{expected for object types}{expected.object}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}

namespace std {
namespace experimental {

  template <class T, class E>
  class expected
  {
  public:
    typedef T value_type;
    typedef E error_type;
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept(see below);
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr expected(const T&);
    constexpr expected(T&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);     
    template <class U, class... Args>
      constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
      
    constexpr expected(unexpected<E> const&);
    template <class Err> 
    constexpr expected(unexpected<Err> const&);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    template <class U> expected& operator=(U&&);
    template <class... Args> void emplace(Args&&...);
    template <class U, class... Args>
      void emplace(initializer_list<U>, Args&&...);

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr T const* operator ->() const;
    T* operator ->();
    constexpr T const& operator *() const;
    T& operator *();
    constexpr explicit operator bool() const noexcept;
    constexpr T const& value() const;
    T& value();
    constexpr E const& error() const;
    E& error();
    template <class U> constexpr T value_or(U&&) const&;
    template <class U> T value_or(U&&) &&;
    template <class G> constexpr T value_or_throw() const&;
    template <class G> T value_or_throw() &&;

  private:
    bool has_value;    // exposition only
    union
    {
      value_type val;  // exposition only
      error_type err;  // exposition only
    };
  };

} // namespace experimental
} // namespace std
\end{lstlisting}


Valued instances of \cpp{expected<T, E>} where \cpp{T} and \cpp{E} is of object type shall contain a value of type \cpp{T} or a value of type \cpp{E} within its own storage. This value is referred to as the contained or the unexpected value of the expected object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained or unexpected value. The contained or unexpected value shall be allocated in a region of the \cpp{expected<T, E>} storage suitably aligned for the type \cpp{T} and \cpp{E}.
\newline

Members \cpp{has_value}, \cpp{val} and \cpp{err} are provided for exposition only. Implementations need not provide those members. \cpp{has_value} indicates whether the expected object's contained value has been initialized (and not yet destroyed); when \cpp{has_value} is true \cpp{val} points to the contained value, and when it is false \cpp{err} points to the erroneous value. \cpp{T} shall be an object type and shall satisfy the requirements of \cpp{Destructible} (Table 24) \todo{ref needed}.

\wordingSubSubSec{Constructors}{expected.object.ctor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Default Constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected() noexcept(see below);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{T()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the default constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_default_constructible<T>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
 \cpp{is_default_constructible<T>::value == true}.
\end{wordingTextItem}


\end{wordingPara}

% Copy Constructor
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(const expected<T, E>& rhs);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{*rhs}.\\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Move Constructor
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(expected<T, E> && rhs) noexcept(/*see below*/);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(*rhs)}. \\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(rhs.error())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)} and \\
\cpp{bool(rhs)} is unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_constructible<T>::value == trye} and   \\
\cpp{is_nothrow_move_constructible<E>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_move_constructible<E>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Value Constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(const T& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{v}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this) == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value == true}. 
\end{wordingTextItem}
\end{wordingPara}

% Move value constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(T&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this) == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor
\begin{lstlisting}[xleftmargin=0pt]
template <class... Args>
constexpr explicit expected(in_place_t, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this) == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor with initializer list.
\begin{lstlisting}[xleftmargin=0pt]
template <class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{il, std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless:\\
\noindent
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.\\

\noindent
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.
\end{wordingTextItem}
\end{wordingPara}


% Unexpected Constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(unexpected<E> const& e);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{e}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this) == false}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<E>::value == true}. 
\end{wordingTextItem}
\end{wordingPara}

% Unexpected move constructor
\begin{lstlisting}[xleftmargin=0pt]
constexpr expected<T, E>::expected(unexpected<E>&& e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(e.value())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this) == false}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{TE}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<E>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Destructor}{expected.object.dtor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Destructor.
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::~expected();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{is_trivially_destructible<T>::value != true} and \cpp{bool(*this)}, calls \cpp{val->T::~T()}.\\
If \cpp{is_trivially_destructible<E>::value != true} and \cpp{bool(*this)}, calls \cpp{err->E::~E()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{is_trivially_destructible<T>::value == true} and \cpp{is_trivially_destructible<E>::value == true} then this destructor shall be a trivial destructor.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Assignment}{expected.object.assign}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Copy Assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>& expected<T, E>::operator=(const expected<T, E>& rhs); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is valued, assigns \cpp{*rhs} to the contained value \cpp{val}, otherwise \\
if \cpp{*this} is valued and \cpp{rhs} is unexpected, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{*this} is unexpected and \cpp{rhs} is unexpected, assigns \cpp{rhs.error()} to the contained value \cpp{err}, otherwise \\
if \cpp{*this} is unexpected and \cpp{rhs} is valued, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{valued} and \cpp{rhs.valued} remain unchanged. If an exception is thrown during the call to \cpp{T}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{T}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{T}'s copy assignment. If an exception is thrown during the call to \cpp{E}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{E}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{E}'s copy assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_assignable<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true} and\\
\cpp{is_copy_assignable<E>::value == true}.
\end{wordingTextItem}

\end{wordingPara}

% Move assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>& expected<T, E>::operator=(expected<T, E>&& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is values, assigns \cpp{std::move(*rhs)} to the contained value \cpp{val}, otherwise \\
if \cpp{*this} is valued and \cpp{rhs} is unexpected, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{*this} is unexpected and \cpp{rhs} is unexpected, assigns \cpp{std::move(rhs.error())} to the contained value \cpp{err}, otherwise  
if \cpp{*this} is unexpected and \cpp{rhs} is valued, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_assignable<T>::value &&}\\
\cpp{is_nothrow_move_constructible<T>::value &&}\\
\cpp{is_nothrow_move_assignable<E>::value &&}\\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{valued} and \cpp{rhs.valued} remain unchanged. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{*rhs.val} is determined by exception safety guarantee of \cpp{T}'s move constructor. If an exception is thrown during the call to \cpp{T}'s move assignment, the state of \cpp{*val} and \cpp{*rhs.val} is determined by exception safety guarantee of \cpp{T}'s move assignment. If an exception is thrown during the call to \cpp{E}'s move constructor, the state of \cpp{*rhs.err} is determined by exception safety guarantee of \cpp{E}'s move constructor. If an exception is thrown during the call to \cpp{E}'s move assignment, the state of \cpp{*err} and \cpp{*rhs.err} is determined by exception safety guarantee of \cpp{E}'s move assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_move_assignable<T>::value == true} and \\
\cpp{is_move_constructible<E>::value == true} and
\cpp{is_move_assignable<E>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Value assignement operator.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
expected<T, E>& expected<T, E>::operator=(U&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{*this} is valued assigns \cpp{std::forward<U>(v)} to the contained value; otherwise destroys the contained value by calling \cpp{err->E::~E()} and initializes the contained value as if direct-non-list-initializing object of type \cpp{T} with \cpp{std::forward<U>(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, value of valued remains unchanged. If an exception is thrown during the call to \cpp{T}'s constructor, the state of \cpp{v} is determined by exception safety guarantee of \cpp{T}'s constructor. If an exception is thrown during the call to \cpp{T}'s assignment, the state of \cpp{*val} and \cpp{v} is determined by exception safety guarantee of \cpp{T}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, U>::value == true} and \\
\cpp{is_assignable<U, T&, U>::value == true}.
\end{wordingTextItem}
\begin{wordingNoteItem}
The reason to provide such generic assignment and then constraining it so that effectively \cpp{T == U} is to guarantee that assignment of the form \cpp{o = \{\}} is unambiguous.
\end{wordingNoteItem}
\end{wordingPara}

% Emplace assignement.
\begin{lstlisting}[xleftmargin=0pt]
template <class... Args>
void expected<T, E>::emplace(Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}if \cpp{*this} is valued, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}, otherwise \\
destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{*val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace with initializer list assignement.
\begin{lstlisting}[xleftmargin=0pt]
template <class U, class... Args>
void expected<T, E>::emplace(initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}, otherwise \\
destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{*val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Swap}{expected.object.swap}
%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap operation.
\begin{lstlisting}[xleftmargin=0pt]
void expected<T, E>::swap(expected<T, E>& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\todo{This must be reworded.}
\begin{wordingPara}


\begin{wordingTextItem}{Effects}
if \cpp{*this} is valued and \cpp{rhs} is unexpected, initializes the contained value of \cpp{rhs} by direct-initialization with \cpp{std::move(*(*this))}, followed by \cpp{val->T::~T()}, \cpp{swap(init, rhs.init)}, otherwise \\
if \cpp{*this} is disengaged and \cpp{rhs} is engaged, initializes the contained value of \cpp{*this} by direct-initialization with \cpp{std::move(*rhs)}, followed by \cpp{rhs.val->T::~T()}, \cpp{swap(init, rhs.init)}, otherwise \\
if both \cpp{*this} and \cpp{rhs} are engaged) calls \cpp{swap(*(*this), *rhs)}. 
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, values of \cpp{init} and \cpp{rhs.init} remain unchanged. If an exception is thrown during the call to function swap the state of \cpp{*val} and \cpp{*rhs.val} is determined by the exception safety guarantee of swap for lvalues of \cpp{T}. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{*val} and \cpp{*rhs.val} is determined by the exception safety guarantee of \cpp{T}'s move constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exceptions that the expressions in the Effects clause throw.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to: \\
\cpp{is_nothrow_move_constructible<T>::value && noexcept(swap(declval<T&>(), declval<T&>())) &&} \\
\cpp{is_nothrow_move_constructible<E>::value && noexcept(swap(declval<E&>(), declval<E&>()))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
LValues of type \cpp{T} shall be swappable, \cpp{is_move_constructible<T>::value == true}, LValues of type \cpp{E} shall be swappable and \cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Observers}{expected.object.observe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -> operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const* expected<T, E>::operator->() const;
T* expected<T, E>::operator->(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
Unless \cpp{T} is a user-defined type with overloaded unary operator\&, the first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% * operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const& expected<T, E>::operator*() const;
T& expected<T, E>::operator*(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{*this} is valued.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% bool convertion operator.
\begin{lstlisting}[xleftmargin=0pt]
constexpr explicit expected<T, E>::operator bool() noexcept; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{has_value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[xleftmargin=0pt]
constexpr T const& expected<T, E>::value() const;
T& expected<T, E>::value(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{*val}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access if !*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value_or method.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
constexpr T expected<T, E>::value_or(U&& v) const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? **this : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or.
\begin{lstlisting}[xleftmargin=0pt]
template <class U>
T expected<T, E>::value_or(U&& v) &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% value_or_throw method.
\begin{lstlisting}[xleftmargin=0pt]
template <class G>
constexpr T expected<T, E>::value_or() const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{**this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! bool(*this)} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or_throw.
\begin{lstlisting}[xleftmargin=0pt]
template <class G>
T expected<T, E>::value_or() &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{std::move(**this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value == true} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{*val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! bool(*this)} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_convertible<U&&, T>::value == true}.
\end{wordingTextItem}
\end{wordingPara}


\wordingSubSec{expected for void}{expected.object.void}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
namespace experimental {

  template <class E>
  class expected<void, E>
  {
  public:
    typedef void value_type;
    typedef E error_type;
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept;
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr explicit expected(in_place_t);     
      
    constexpr expected(unexpected<E> const&);
    template <class Err> 
    constexpr expected(unexpected<Err> const&);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    void emplace();

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr explicit operator bool() const noexcept;
    void value() const;
    constexpr E const& error() const;
    E& error();

  private:
    bool has_value;    // exposition only
    union
    {
      unsigned char dummy;  // exposition only
      error_type err;  // exposition only
    };
  };

} // namespace experimental
} // namespace std
\end{lstlisting}


\wordingSubSec{Unexpected object type}{expected.exceptional}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unexpected object type
\begin{lstlisting}
template <class E=std::exception_ptr>
class unexpected {
public:
    constexpr unexpected();
    constexpr unexpected(E&);   
    constexpr unexpected(E&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);
    template <class U, class... Args>
      constexpr explicit expected(in_place_t,
                                  initializer_list<U>, Args&&...);
}; 

template <>
struct unexpected<std::exception_ptr> {
    constexpr unexpected();
    constexpr unexpected(std::exception_ptr);
    template <class E>
      constexpr unexpected(E&);
    template <class E>
      constexpr unexpected(E&&);

}; 

\end{lstlisting}
\noindent


\wordingSubSec{Class bad_expected_access}{expected.bad_expected_access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
  class bad_expected_access : public logic_error {
  public:
    explicit bad_expected_access(const string& what_arg);
    explicit bad_expected_access(const char* what_arg);
  };
}
\end{lstlisting}
The class \cpp{bad_expected_access} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a unexpected expected object.

% constructor with string message.
\begin{lstlisting}[xleftmargin=0pt]
bad_expected_access(const string& what_arg); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{strcmp(what(), what_arg.c_str()) == 0}.
\end{wordingTextItem}
\end{wordingPara}

% constructor with char* message.
\begin{lstlisting}[xleftmargin=0pt]
bad_expected_access(const char* what_arg); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{strcmp(what(), what_arg) == 0}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Relational operators}{expected.relational_op}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{Comparison with T}{expected.comparison_T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{Specialized algorithms}{expected.specalg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap free function.
\begin{lstlisting}[xleftmargin=0pt]
template <class T, class E>
void swap(expected<T, E>& x, expected<T, E>& y) noexcept(noexcept(x.swap(y))); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
calls \cpp{x.swap(y)}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Factories}{expected.factories}

% make_expected move value factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<typename decay<T>::type> make_expected(T&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<typename decay<T>::type>(std::forward<T>(v))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected factory.
\begin{lstlisting}[xleftmargin=0pt]
template <>
constexpr expected<void> make_expected(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<void>(in_place)}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<T> make_expected_from_error(std::exception_ptr v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<T>(unexpected(std::forward<E>(v)))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[xleftmargin=0pt]
template <class T, class E>
constexpr expected<T> make_expected_from_error(E&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
Equivalent to:
\begin{lstlisting}
if(typeid(e)!=typeid(E)){
  throw invalid_argument( "slicing detected");
}
return make_expected_from_error<T>(make_exception_ptr(v));
\end{lstlisting}
\end{wordingTextItem}
\end{wordingPara}


% make_expected_from_error factory (flying exception).
\begin{lstlisting}[xleftmargin=0pt]
template <class T>
constexpr expected<T> make_expected_from_error(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{make_expected_from_error<T>(std::current_exception())}
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_call
\begin{lstlisting}[xleftmargin=0pt]
template <class F>
constexpr typename expected<result_type<F>::type make_expected_from_call(F f);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Hash support}{expected.hash}

\begin{lstlisting}[xleftmargin=0pt]
template <class T, class E>
struct hash<expected<T, E>>; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\todo{This must be reworded}

The template specilaization \cpp{hash<T>} and \cpp{hash<E>} shall meet the requirements of class template \cpp{hash} (Z.X.Y). The template specialization \cpp{hash<expected<T, E>>} shall meet the requirements of class template \cpp{hash}. For an object \cpp{o} of type \cpp{expected<T, E>}, \cpp{if bool(o) == true}, \cpp{hash<expected<T, E>>()(o)} shall evaluate to the same value as \cpp{hash<T, E>()(*o);} otherwise it evaluates to an unspecified value.
\end{wordingTextItem}
\end{wordingPara}

\begin{lstlisting}[xleftmargin=0pt]
template <class E>
struct hash<expected<void, E>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\end{wordingTextItem}
\end{wordingPara}

\section{Implementability}
This proposal can be implemented as pure library extension, without any compiler magic support, in C++14. An almost full reference implementation of this proposal can be found at TBoost.Expected \cite{boost.expected}. 
\section{Acknowledgement}

We are very grateful to Andrei Alexandrescu for his talk, which was the origin of this work.
We thanks also to every one that has contributed to the Haskell either monad, as either's interface was a source of inspiration.
Thanks to Fernando Cacciola, Andrzej Krzemieński and every one that has contributed to the wording of N3793 \cite{OptionalRev5}.

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}