\documentclass[a4paper,10pt]{article}
\usepackage[american]
           {babel} % needed for iso dates
\usepackage{url}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{array}
\usepackage{underscore}
\usepackage{changepage}   % for the adjustwidth environment

\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{color}
\usepackage{textpos}
\usepackage{titling}
\usepackage{titlesec}

\hypersetup{
  hidelinks
}

\setcounter{secnumdepth}{6}

% From std draft
% We use the 'listings' package, with some small customizations.  The
% most interesting customization: all TeX commands are available
% within comments.  Comments are set in italics, keywords and strings
% don't get special treatment.
% General code style
\lstset{language=C++,
        basicstyle=\small\ttfamily,
        keywordstyle=,
        stringstyle=,
        xleftmargin=1em,
        showstringspaces=false,
        commentstyle=\itshape\rmfamily,
        columns=flexible,
        keepspaces=true,
        texcl=true
}
% end from std draft

\newcommand{\wordingSec}[2]{\vspace{15pt}
\noindent
{\large\textbf{X.Y\quad #1\hfill\textbf{[#2]}}}
}

% Counters
\newcounter{countWordingSubSec}
\newcounter{countWordingSubSubSec}[countWordingSubSec]

\renewcommand{\thecountWordingSubSec}{X.Y.\arabic{countWordingSubSec}}
\renewcommand{\thecountWordingSubSubSec}{X.Y.\arabic{countWordingSubSec}.\arabic{countWordingSubSubSec}}

% Defs of sub and subsub section (for the wording).
\newcommand{\wordingSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSec}
\noindent
{\textbf{\thecountWordingSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\wordingSubSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSubSec}
\noindent
{\textbf{\thecountWordingSubSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\cpp}[1]{\lstinline{#1}}

\newcommand{\todo}[1]{\emph{\textcolor{red}{TODO: #1}}}

% Wording items
\newcommand{\wordingItem}[1]{\noindent\textit{#1:}}

\newenvironment{wordingTextItem}[1]{\wordingItem{#1}\vspace{2pt}\noindent\begin{adjustwidth}{12pt}{}}{\vspace{2pt}\end{adjustwidth}}

\newenvironment{wordingNoteItem}{[\wordingItem{Note}}{---\textit{end note}]}

\newenvironment{wordingPara}{\begin{adjustwidth}{12pt}{}}{\end{adjustwidth}}

\lstset{
  xleftmargin=12pt
}

\setlength{\droptitle}{10em}
\title{A proposal to add a utility class to represent expected monad}
\author{}
\date{}

\begin{document}

\maketitle
\begin{textblock*}{9cm}(7cm,-8cm)
\begin{tabular}{l l}
\textbf{Document number:} & N4015 \\
\textbf{Date:}  & 2014/05/21 \\
\textbf{Revises:} & None \\
\textbf{Project:} & JTC1.22.32 Programming \\
 & Language C++ \\
\textbf{Reply to:} & Vicente J. Botet Escriba \\
 & <\href{mailto:vicente.botet@wanadoo.fr}{vicente.botet@wanadoo.fr}> \\
 & Pierre Talbot <\href{mailto:ptalbot@hyc.io}{ptalbot@hyc.io}>
\end{tabular}
\end{textblock*}

\vspace{-6em}
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}
%%%%%%%%%%%

Class template \cpp{expected<E,T>} proposed here is a type that may contain a value of type \cpp{T} or a value of type \cpp{E} in its storage space. \cpp{T} represents the expected value, \cpp{E} represents the reason explaining why it doesn't contains a value of type \cpp{T}, that is the unexpected value. Its interface allows to query if the underlying value is either the expected value (of type \cpp{T}) or an unexpected value (of type \cpp{E}). The original idea comes from Andrei Alexandrescu C++ and Beyond 2012: Systematic Error Handling in C++ talk \cite{AlexandrescuExpected}. The interface and the rational are based on \cpp{std::optional} N3793 \cite{OptionalRev5} and Haskell monads. We can consider that \cpp{expected<E,T>} is a generalization of \cpp{optional<T>} providing in addition a monad interface and some specific functions associated to the unexpected type \cpp{E}. It requires no changes to core language, and breaks no existing code.

\section{Motivation and Scope}
\label{motiv-scope}
%%%%%%%%%%%%%%%%

Basically, the two main error mechanisms are exceptions and return codes. Before further explanation, we should ask us what are the characteristics of a good error mechanism.

\begin{itemize}
 \item \textbf{Error visibility} Failure cases should appears throughout the code review. Because the debug can be painful if the errors are hidden.
 \item \textbf{Information on errors} The errors should carry out as most as possible information from their origin, causes and possibly the ways to resolve it.
 \item \textbf{Clean code} The treatment of errors should be in a separate layer of code and as much invisible as possible. So the code reader could notice the presence of exceptional cases without stop his reading.
 \item \textbf{Non-Intrusive error} The errors should not monopolize a communication channel dedicated to the normal code flow. They must be as discrete as possible. For instance, the return of a function is a channel that should not be exclusively reserved for errors.
\end{itemize}

The first and the third characteristic seem to be quite contradictory and deserve further explanation. The former points out that errors not handled should appear clearly in the code. The latter tells us that the error handling mustn't interfere with the code reading, meaning that it clearly shows the normal execution flow. A comparison between the exception and return codes is given in the table \ref{comp-handling-error}.

\begin{table}[h!]
\centering
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
                    & \textbf{Exception} & \textbf{Return code} \\
\hline
\textbf{Visibility} & Not visible without further analysis of the code. However, if an exception is thrown, we can follow the stack trace. & Visible at the first sight by watching the prototype of the called function. However ignoring return code can lead to undefined results and it can be hard to figure out the problem. \\
\hline
\textbf{Informations} & Exceptions can be arbitrarily rich. & Historically a simple integer. Nowadays, the header \cpp{<system_error>} provides richer error code. \\
\hline
\textbf{Clean code} & Provides clean code, exceptions can be completely invisible for the caller. & Force you to add, at least, a if statement after each function call. \\
\hline
\textbf{Non-Intrusive} & Proper communication channel. & Monopolization of the return channel. \\
\hline
\end{tabular}
\egroup
\caption{Comparison between two error handling systems.}
\label{comp-handling-error}
\end{table}

\subsection{Expected class}
%%%%%%%%%%%%%%%%%%%%

We can do the same analysis for the \cpp{Expected<E, T>} class and observe the advantages over the classic error reporting systems.

\begin{itemize}
 \item \textbf{Error visibility} It takes the best of the exception and error code. It's visible because the return type is Expected<E, T> and the user cannot ignore the error case if he wants to retrieve the contained value.
 \item \textbf{Information} Arbitrarily rich.
 \item \textbf{Clean code} The monadic interface of expected provides a framework delegating the error handling to another layer of code. Note that \cpp{Expected<E, T>} can also act as a bridge between an exception-oriented code and a nothrow world.
 \item \textbf{Non-Intrusive} Use the return channel without monopolizing it.
\end{itemize}

\noindent
It worths mentioning the other characteristics of \cpp{Expected<E, T>}:

\begin{itemize}
 \item Associates errors with computational goals.
 \item Naturally allows multiple errors inflight.
 \item Teleportation possible.
 \begin{itemize}
  \item Across thread boundaries.
  \item Across nothrow subsystem boundaries.
  \item Across time: save now, throw later.
 \end{itemize}
 \item Collect, group, combine errors.
\end{itemize}

\section{Use cases}
%%%%%%%%%%

\subsection{Safe division}
\label{divide-example}
%%%%%%%%%%%

This example shows how to define a safe divide operation checking for divide-by-zero conditions. Using exceptions, we might write something like this:

\begin{lstlisting}
struct DivideByZero: public std::exception {...};

double safe_divide(double i, double j)
{
  if (j==0) throw DivideByZero();
  else return i / j;
}
\end{lstlisting}

With \cpp{Expected<E,T>}, we are not required to use exceptions, we can use \cpp{std::error_condition} which is easier to introspect than \cpp{std::exception_ptr} if we want to use the error. For the purpose of this example, we use the following enumeration (the boilerplate code concerning \cpp{std::error_condition} is not shown):

\begin{lstlisting}
enum class arithmetic_errc
{
  divide_by_zero,   // 9/0 == ?
  not_integer_division  // 5/2 == 2.5 (which is not an integer)
};
\end{lstlisting}

\noindent
Using \cpp{expected<error_condition, double>}, the code becomes:

\begin{lstlisting}
expected<error_condition, double> safe_divide(double i, double j)
{
  if (j==0) return make_unexpected(arithmetic_errc::divide_by_zero); // (1)
  else return i / j; // (2)
}
\end{lstlisting}

(1) The implicit conversion from \cpp{unexpected_type<E>} to \cpp{expected<E,T>} and (2) from \cpp{T} to \cpp{expected<E,T>} prevents using too much boilerplate code. The advantages are that we have a clean way to fail without using the exception machinery, and we can give precise information about why it failed as well. The liability is that this function is going to be tedious to use. For instance, the exception-based function $i + j/k$ is:

\begin{lstlisting}
double f1(double i, double j, double k)
{
  return i + safe_divide(j,k);
}
\end{lstlisting}

\noindent
but becomes using \texttt{expected<error_condition, double>}:

\begin{lstlisting}
expected<error_condition, double> f1(double i, double j, double k)
{
  auto q = safe_divide(j, k)
  if(q) return i + *q;
  else return q;
}
\end{lstlisting}

\noindent
This example clearly doesn't respect the ``clean code'' characteristic introduced in section \ref{motiv-scope} and the readability doesn't differ much from the ``C return code''. Hopefully, we can see \cpp{expected<E,T>} through functional glasses as a monad. The code is cleaner using the member function \cpp{map}. This way, the error handling is not explicitly mentioned but we still know, thanks to the call to \cpp{map}, that something is going underneath and thus it is not as silent as exception.

\begin{lstlisting}
expected<error_condition, double> f1(double i, double j, double k)
{
  return safe_divide(j, k).map([&](double q){
    return i + q;
  });
}
\end{lstlisting}

The \cpp{map} member calls the continuation provided if expected contains a value, otherwise it forwards the error to the callee. Using lambda function might clutter the code, so here the same example using functor:

\begin{lstlisting}
expected<error_condition, double> f1(double i, double j, double k)
{
  return safe_divide(j, k).map(bind(plus, i, _1));
}
\end{lstlisting}

We can use \cpp{expected<E, T>} to represent different error conditions. For instance, with integer division, we might want to fail if the two numbers are not evenly divisible as well as checking for division by zero. We can overload our \cpp{safe_divide} function accordingly:

\begin{lstlisting}
expected<error_condition, int> safe_divide(int i, int j)
{
  if (j == 0) return make_unexpected(arithmetic_errc::divide_by_zero); 
  if (i%j != 0) return make_unexpected(arithmetic_errc::not_integer_division);
  else return i / j;
}
\end{lstlisting}

Now we have a division function for integers that possibly fail in two ways. We continue with the exception-oriented function $i/k + j/k$:

\begin{lstlisting}
int f2(int i, int j, int k)
{
  return safe_divide(i,k) + safe_divide(j,k);
}
\end{lstlisting}

\noindent
Now let's write this code using an \cpp{expected<E,T>} type and the functional \cpp{map} already used previously.

\begin{lstlisting}
expected<error_condition, int> f(int i, int j, int k)
{
  return safe_divide(i, k).map([=](int q1) {
      return safe_divide(j,k).map([=](int q2) {
        return q1+q2;
      });
    });
}
\end{lstlisting}

The compiler will gently say he can convert an \cpp{expected<error_condition, expected<error_condition, int>>} to \cpp{expected<error_condition, int>}. This is because the member \cpp{map} wraps the result in Expected and since we use twice the \cpp{map} member it wraps it twice. The \cpp{bind}\footnote{To not confound with \cpp{std::bind} which is not related to monad.} member wraps the result of the continuation only if it is not already wrapped. The correct version is as follow:

\begin{lstlisting}
expected<exception_ptr,int> f(int i, int j, int k)
{
  return safe_divide(i, k).bind([=](int q1) {
      return safe_divide(j,k).map([=](int q2) {
        return q1+q2;
      });
    });
}
\end{lstlisting}

The error-handling code has completely disappeared but the lambda functions are a new source of noise, and this is even more important with $n$ expected variables. Propositions for a better monadic experience are discussed in section \ref{better-support-for-monad}, the subject is left open and is considered out of scope of this proposal.

\subsection{Error retrieval and correction}
%%%%%%%%%%%%%%%%

The major advantage of \cpp{expected<E,T>} over \cpp{optional<T>} is the ability to transport an error, but we didn't come yet to an example that retrieve the error. First of all, we should wonder what a programmer do when a function call returns an error:

\begin{enumerate}
 \item Ignore it.
 \item Delegate the responsibility of error handling to higher layer.
 \item Trying to resolve the error.
\end{enumerate}

Because the first behavior might lead to buggy application, we won't consider it in a first time. The handling is dependent of the underlying error type, we consider the \cpp{exception_ptr} and the \cpp{error_condition} types.

We spoke about how to use the value contained in the Expected but didn't discuss yet the error usage. A first imperative way to use our error is to simply extract it from the Expected using the \cpp{error()} member function. The following example shows a \cpp{divide2} function that return 0 if the error is \cpp{divide_by_zero}:

\begin{lstlisting}
expected<error_condition, int> divide2(int i, int j)
{
  auto e = safe_divide(i,j);
  if (!e && e.error().value() == arithmetic_errc::divide_by_zero) {
    return 0;
  }
  return e;
}
\end{lstlisting}

This imperative way is not entirely satisfactory since it suffers from the same disadvantages than \cpp{value()}. Again, a functional view leads to a better solution. The \cpp{catch_error} member calls the continuation passed as argument if the expected is erroneous.

\begin{lstlisting}
expected<error_condition, int> divide3(int i, int j)
{
  auto e = safe_divide(i,j);
  return e.catch_error([](const error_condition& e){
    if(e.value() == arithmetic_errc::divide_by_zero)
    {
      return 0;
    }
    return make_unexpected(e);
  });
}
\end{lstlisting}

An advantage of this version is to be coherent with the \cpp{bind} and \cpp{map} functions. It also provides a more uniform way to analyze error and recover from some of these. Finally, it encourages the user to code its own ``error-resolver'' function and leads to a code with distinct treatment layers.

\subsection{A Configurable Expected}

Expected is configurable through the trait \cpp{expected_traits}. The first variation point is the behavior of \cpp{value()} when \cpp{expected<E,T} contains an error. A default strategy would throw a \cpp{bad_expected_access} exception but it might not be satisfiable for every error types. For example, some might want to encapsulate an \cpp{error_condition} into a specific exception. In debug mode, they might want to use an \cpp{assert} call.

The other variation point is the behavior triggered when the continuation argument of \cpp{bind} or \cpp{map} throws an exception. If the exception thrown is \cpp{system_error} and error type of Expected is \cpp{error_code}, we might want to simply store the contained error. Without more discussion, let's show how to customize \cpp{expected<E, T>}, consider the following exception-oriented function:

\begin{lstlisting}
class error_cond : public std::exception {
  // Implementation similar to system_error but for error_condition here.
};

int safe_divide(int i, int j)
{
  if (j == 0) 
    throw error_cond(error_condition(arithmetic_errc::divide_by_zero));
  return i/j;
}
\end{lstlisting}

Imagine \cpp{j} encapsulated into an \cpp{expected}, you will call \cpp{map} with \cpp{safe_divide} as the continuation. Let's see what it looks like:

\begin{lstlisting}
expected<error_condition, int> f(int i, const expected<error_condition, int>& j)
{
  return j.map(bind(safe_divide, i, _1));
}
\end{lstlisting}

If we specialize \cpp{expected_traits} for \cpp{error_condition}, we can achieve the expected behavior:

\begin{lstlisting}
template <class T>
struct expected_traits<expected<error_condition, T>>
{
  static expected<error_condition, T> catch_exception()
  {
    try{
      rethrow_exception(current_exception());
    } catch(const error_cond& e) {
      return make_unexpected(e.code());
    }
  }

  static void bad_access(const error_type &e)
  {
    throw error_cond(e);
  }
};
\end{lstlisting}

The semantics of \cpp{catch_exception} is to rethrow the current exception and catch only the exceptions we are interest in. The default behavior let flight the exception thrown by the continuation. We created a bridge between an \cpp{error_condition} and the \cpp{error_cond} exception. More insight on link between Expected and exceptions in the section \ref{expected-traits-rational}.

\section{Impacts on the Standard}
%%%%%%%%%%%%%%%%%

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++ 14. It requires however the \cpp{in_place_t} from N3793.

\section{Design rationale}
%%%%%%%%%%%%%

The same rationale described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>} and \cpp{expected< nullopt_t, T>} should behave as \cpp{optional<T>}.  That is, we see \cpp{expected<E,T>} as \cpp{optional<T>} for which all the values of \cpp{E} collapse into a single value \cpp{nullopt}. In the following sections we present the specificities of the rationale in \cite{OptionalRev4} applied to  \cpp{expected<E,T>}.

\subsection{Conceptual model of \cpp{expected<E,T>}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cpp{expected<E,T>} models a discriminated union of types \cpp{T} and \cpp{unexpected_type<E>}. \cpp{expected<E,T>} is viewed as a value of type \cpp{T} or value of type \cpp{unexpected_type<E>}, allocated in the same storage, along with the way of determining which of the two it is. 

The interface in this model requires operations such as comparison to \cpp{T}, comparison to \cpp{E}, assignment and creation from either. It is easy to determine what the value of the expected object is in this model: the type it stores (\cpp{T} or \cpp{E}) and either the value of \cpp{T} or the value of \cpp{E}. 

Additionally, within the affordable limits, we propose the view that \cpp{expected<E,T>} extends the set of the values of \cpp{T} by the values of type \cpp{E}. This is reflected in initialization, assignment, ordering, and equality comparison with both \cpp{T} and \cpp{E}. In the case of  \cpp{optional<T>}, \cpp{T} can not be a \cpp{nullopt_t}. As the types \cpp{T} and \cpp{E} could be the same in \cpp{expected<E,T>}, there is need to tag the values of \cpp{E} to avoid ambiguous expressions. The \cpp{make_unexpected(E)} function is proposed for this purpose. However \cpp{T} can not be  \cpp{unexpected_type<E>} for a given \cpp{E}.

\begin{lstlisting}
expected<string, int> ei = 0;
expected<string, int> ej = 1;
expected<string, int> ek = make_unexpected(string());

ei = 1;
ej = make_unexpected(E());;
ek = 0;

ei = make_unexpected(E());;
ej = 0;
ek = 1;
\end{lstlisting}

\subsection{Initialization of \cpp{expected<E,T>}}
%%%%%%%%%%%%%%%%%%%%%%%

In cases \cpp{T} and \cpp{E} are value semantic types capable of storing \cpp{n} and \cpp{m} distinct values respectively, \cpp{expected<E,T>} can be seen as an extended \cpp{T} capable of storing \cpp{n + m} values: these that \cpp{T} and \cpp{E} stores. Any valid initialization scheme must provide a way to put an expected object to any of these states. In addition, some \cpp{T}'s  are not \cpp{CopyConstructible} and their expected variants still should constructible with any set of arguments that work for \cpp{T}. 

As in \cite{OptionalRev4}, the model retained is to initialize either by providing either an already constructed \cpp{T} or a tagged \cpp{E}.

\begin{lstlisting}
string s{"STR"};

expected<exception_ptr,string> es{s};                    // requires Copyable<T>
expected<exception_ptr,string> et = s;                   // requires Copyable<T>
expected<exception_ptr,string> ev = string{"STR"};       // requires Movable<T>

expected<exception_ptr,string> ew;                       // unexpected value
expected<exception_ptr,string> ex{};                     // unexpected value
expected<exception_ptr,string> ey = {};                  // unexpected value
expected<exception_ptr,string> ez = expected<exception_ptr,string>{};  // unexpected value
\end{lstlisting}

In order to create a unexpected object a special function needs to be used: \cpp{make_unexpected}:

\begin{lstlisting}
expected<int, string> ep{make_unexpected(-1)};              // unexpected value, requires Movable<E>
expected<int, string> eq = {make_unexpected(-1)};           // unexpected value, requires Movable<E>
\end{lstlisting}

As in \cite{OptionalRev4}, and in order to avoid calling move/copy constructor of \cpp{T}, we use a 'tagged' placement constructor: 

\begin{lstlisting}
expected<exception_ptr,MoveOnly> eg;                        // unexpected value
expected<exception_ptr,MoveOnly> eh{};                      // unexpected value
expected<exception_ptr,MoveOnly> ei{in_place};               // calls MoveOnly{} in place
expected<exception_ptr,MoveOnly> ej{in_place, "arg"};        // calls MoveOnly{"arg"} in place
\end{lstlisting}

To avoid calling move/copy constructor of \cpp{E}, we use a 'tagged' placement constructor: 

\begin{lstlisting}
expected<string,int> ei{unexpect};               // unexpected value, calls string{} in place
expected<string,int> ej{unexpect, "arg"};        // unexpected value, calls string{"arg"} in place
\end{lstlisting}

An alternative name for \cpp{in_place} that is coherent with the \cpp{unexpect} could be \cpp{expect}. Been compatible with \cpp{optional<T>} seems more important. So this proposal doesn't propose such a \cpp{expect} tag.

The alternative and also comprehensive initialization approach, which is not compatible with the choice to default construct \cpp{expected<E,T>} to \cpp{E()}, could be to have a variadic perfect forwarding constructor that just forwards any set of arguments to the constructor of the contained object of type \cpp{T}. 
 
\subsection{Almost Never-empty guaranty}
%%%%%%%%%%%%%%%%%%

As \cpp{boost::variant<unexpected_type<E>,T}, \cpp{expected<E,T>} ensures that it is never empty.
All instances \cpp{v} of type \cpp{expected<E,T>} guarantee that \cpp{v} has constructed content of one of the types \cpp{T} or \cpp{E}, even if an operation on \cpp{v} has previously failed.

This implies that expected may be viewed precisely as a union of exactly its bounded types. This "never-empty" property insulates the user from the possibility of undefined expected content and the significant additional complexity-of-use attendant with such a possibility.

\subsubsection{The default constructor}
%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item \cpp{std::experimental::optional<T>} default constructs to an optional with no value. 
\item \cpp{boost::variant<T,E>} default constructs to a variant with the value \cpp{T()} it \cpp{T} is default constructible or to the value \cpp{E()} it \cpp{E} is default constructible or it is ill formed otherwise. 
\item \cpp{std::future<T>} default constructs to an invalid future with no shared state associated, that is, no value and no exception.
\item \cpp{std::experimental::optional<T>} default constructor is equivalent to \cpp{boost::variant<nullopt_t, T>}.
\end{itemize}

\begin{itemize}
\item Should the default constructor of \cpp{std::experimental::expected<E,T>} behave like \cpp{boost::variant<T,E>} or as \cpp{boost::variant<E,T>}?
\item Should the default constructor of \cpp{std::experimental::expected<E,T>} behave like \cpp{std::experimental::optional<boost::variant<T,E>>}?
\item Should the default constructor of \cpp{std::experimental::expected<nullopt_t,T>} behave like \cpp{std::experimental::optional<T>}? If yes, how should behave the default constructor of \cpp{std::experimental::expected<E,T>}? as if initialized with \cpp{make_unexpected(E())}? This will be equivalent to the initialization of \cpp{boost::variant<E,T>}.
\item Should \cpp{std::experimental::expected<E,T>} provide a default constructor at all? \cite{OptionalRev3} present valid arguments against this approach, e.g. \cpp{array<optional<T>>} would not be possible. 
\end{itemize}

Requiring \cpp{E} to be default constructible seems less constraining than requiring \cpp{T} to be default constructible. E.g. consider the \cpp{Date} example in \cite{OptionalRev3}. With the same semantics \cpp{expected<E,Date>} would be \cpp{Regular} with a meaningful not-a-date state created by default.

There is still a minor issue as the default constructor of \cpp{std::exception_ptr} doesn't contains an exception and so getting the value of a default constructed \cpp{expected<exception_ptr, T>} would need to check if the stored \cpp{std::exception_ptr} is equal to \cpp{std::exception_ptr()} and throw a specific exception.

The authors consider the arguments in  \cite{OptionalRev3} valid and so propose that \cpp{expected<E,T>} default constructor should behave as constructed with \cpp{make_unexpected(E())}.

\subsubsection{Conversion from \cpp{T}}
%%%%%%%%%%%%%%%%%%

An object of type \cpp{T} is convertible to an expected object of type \cpp{expected<E,T>}:

\begin{lstlisting}
expected<exception_ptr,int> ei = 1; // works
\end{lstlisting}

This convenience feature is not strictly necessary because you can achieve the same effect by using tagged forwarding constructor:

\begin{lstlisting}
expected<exception_ptr,int> ei{in_place, 1};
\end{lstlisting}

If the latter appears too inconvenient, one can always use function \cpp{make_expected} described below:

\begin{lstlisting}
expected<exception_ptr,int> ei = make_expected(1); 
auto ej = make_expected(1); 
\end{lstlisting}

\subsubsection{Using \cpp{make_unexpected} to convert from \cpp{E}}
%%%%%%%%%%%%%%%%%%

An object of type \cpp{E} is not convertible to an unexpected object of type \cpp{expected<E,T>}:

The proposed interface uses a special tag \cpp{unexpect} and a special non-member \cpp{make_unexpected} function to indicate an unexpected state for \cpp{expected<E,T>}. It is used for construction and assignment. This might rise a couple of objections. First, this duplication is not strictly necessary because you can achieve the same effect by using the \cpp{unexpect} tagged forwarding constructor:

\begin{lstlisting}
expected<int, string> exp1 = make_unexpected(1); 
expected<int, string> exp2 = {unexpect, 1}; 

exp1 =   make_unexpected(1);
exp2 =  {unexpect, 1};

\end{lstlisting}

While some situations would work with {unexpect, ...} syntax, using \cpp{make_expected} makes the programmer's intention as clear and less cryptic. Compare these:

\begin{lstlisting}
expected<int, vector<int>> get1() {
  return {unexpect, 1};
}

expected<int, vector<int>> get2() {
  return make_unexpected(1);
}

expected<int, vector<int>> get3() {
  return expected<int, vector<int>>{unexpect, 1};
}
\end{lstlisting}

The usage of \cpp{make_unexpected} is also a consequence of the adapted model for expected: a discriminated union of \cpp{T} and \cpp{unexpected_type<E>}. 
While \cpp{make_unexpected(E)} has been chosen because it clearly indicates that we are interested in creating an unexpected \cpp{expected<E,T>} (of unspecified type \cpp{T}), it could be used also to make a ready future with a specific exception, but this is outside the scope of this proposal.

Note also that the definition of the result type of \cpp{make_unexpected} has explicitly deleted default constructor. This is in order to enable the reset idiom 

\begin{lstlisting}
exp2 = {};
\end{lstlisting}

which would otherwise not work because of ambiguity when deducing the right-hand side argument.

\subsubsection{Why not a \cpp{make_unexpected} nested function on \cpp{expected<E,T>}?}
%%%%%%%%%%%%%%%%%%

\cite{AlexandrescuExpected} \cpp{Expected<T>} class has a nested member function \cpp{Expected<T>::from_error(E)} instead of the free function \cpp{make_unexpected}. But the proposed \cpp{expected<E,T>} has an additional template parameter \cpp{E} and so the type \cpp{E} would be explicit.

\begin{lstlisting}
expected<unsigned, string> ei = expected<unsigned, string>::make_unexpected(1);
\end{lstlisting}

This has however several advantages. Namespace \cpp{std} is not polluted with an additional expected-specific name. Also, it resolves certain ambiguities when types like expected<E, expected<E,T>> are involved:

\begin{lstlisting}
expected<int, expected<int, string>> eei = 
    expected<int, string>::make_unexpected(1);           // valued
expected<int, expected<int, string>> eej = 
    expected<int, expected<int, string>>::make_unexpected(1); // disengaged

void fun(expected<int, string>);
void fun(expected<int, int>);

fun(expected<int, string>::make_unexpected(1)); // unambiguous: a typeless make_unexpected would not do 
\end{lstlisting}

Yet, we choose to propose a free function because we consider the above problems rare and a free function offers a very short notation in other cases:

\begin{lstlisting}
expected<int, string> fun()
{
  expected<int, string> ei = make_unexpected(1);  // no ambiguity
  ei = make_unexpected(1);                // no ambiguity
  // ...
  return make_unexpected(1);              // no ambiguity
}
\end{lstlisting}

If the typeless function does not work for you, you can always use the following construct, although at the expense of invoking a (possibly elided) move constructor:

\begin{lstlisting}
expected<int, expected<int, string>> eei = 
    expected<int, string>{make_unexpected(1)};           // valued
expected<int, expected<int, string>> eej = 
    expected<int, expected<int, string>>{make_unexpected(1)}; // unexpected

void fun(expected<int, string>);
void fun(expected<int,int>);

fun(expected<int, string>{make_unexpected(1)}); // unambiguous 
\end{lstlisting}

\subsubsection{Handling \cpp{initializer_list}}
%%%%%%%%%%%%%%%%%%

\subsection{Observers}
%%%%%%%%%%%%%%%%%%

In order to be as efficient as possible, this proposal includes observers with narrow and wide contracts. Thus, the \cpp{value()} function has a wide contract. If the expected object doesn't contains a value an exception is throw. However, when the user know that the expected object is valid, the use of \cpp{operator*} would be more appropriated. 

\subsubsection{Explicit conversion to \cpp{bool}}
%%%%%%%%%%%%%%%%%%

The same rational described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>} and so, the following example would combine initialization and  checking for been valued in a condition.

\begin{lstlisting}
if (expected<exception_ptr, char> ch = readNextChar()) {
  // ...
}
\end{lstlisting}


\subsubsection{Accessing the contained value}
%%%%%%%%%%%%%%%%%%

Even if \cpp{expected<E,T>} has not been used in practice for a while as Boost.Optional, we consider that following the same interface that \cpp{std::experimental::optional<T>} makes the C++ standard library more homogeneous. 

The same rational described in \cite{OptionalRev4} for \cpp{optional<T>} applies to \cpp{expected<E,T>}. 

\subsubsection{Dereference operator}
%%%%%%%%%%%%%%%%%%

It was chosen to use indirection operator because, along with explicit conversion to \cpp{bool}, it is a very common pattern for accessing a value that might not be there:

\begin{lstlisting}
if (p) use(*p);
\end{lstlisting}

This pattern is used for all sort of pointers (smart or dumb), \cpp{optional} and it clearly indicates the fact that the value may be missing and that we return a reference rather than a value. The indirection operator has risen some objections because it may incorrectly imply that \cpp{expected} and \cpp{optional} are a (possibly smart) pointer, and thus provides shallow copy and comparison semantics. All library components so far use indirection operator to return an object that is not part of the pointer's/iterator's value. In contrast, \cpp{expected} as \cpp{optional} indirects to the part of its own state. We do not consider it a problem in the design; it is more like an unprecedented usage of indirection operator. We believe that the cost of potential confusion is overweighed by the benefit of an easy to grasp and intuitive interface for accessing the contained value.

We do not think that providing an implicit conversion to \cpp{T} would be a good choice. First, it would require different way of checking for the empty state; and second, such implicit conversion is not perfect and still requires other means of accessing the contained value if we want to call a member function on it.

Using the indirection operator for a object that doesn't contains a value is an undefined behavior. This behavior offers maximum runtime performance.

\subsubsection{Function value}
%%%%%%%%%%%%%%%%%%

In addition to the indirection operator, we propose the member function value as in \cite{OptionalRev4} that returns a reference to the contained value if one exists or throws an exception otherwise:

\begin{lstlisting}
void interact() {
  std::string s;
  cout << "enter number ";
  cin >> s;
  expected<exception_ptr,int> ei = str2int(s);
  
  try {
    process_int(ei.value());
  }
  catch(bad_expected_access const&) {
    cout << "this was not a number";
  }
}
\end{lstlisting}

The exception thrown depend on the expected error type. By default it throws \cpp{bad_expected_access<E>} (derived from \cpp{logic_error}) which will contain the stored error. In the case \cpp{expected<exception_ptr>}, it thows the exception stored on the \cpp{exception_ptr}.

This function can be implemented easily using the bool conversion and the dereference operator as a non member function

\begin{lstlisting}
  template <class E, class T>
  contexpr T const& value(expected<E,T> const& e)
  {
    if(e) return *e;
    else throw bad_expected_access(e.error());
  }
  template <class E, class T>
  contexpr T & value(expected<E,T>& e)
  {
    if(e) return *e;
    else throw bad_expected_access(e.error());
  }
  template <class T>
  contexpr T const& value(expected<exception_ptr,T> const& e)
  {
    if(e) return *e;
    else rethrow_exception(e.error());
  }
  template <class T>
  contexpr T & value(expected<exception_ptr,T>& e)
  {
    if(e) return *e;
    else rethrow_exception(e.error());
  }
\end{lstlisting}

The advantage is the user could overload the function for other errors, as \cpp{any}, \cpp{variant<E1, ...., En>}. The liability is that free functions introduce a new name on the std namespace. Adding it to a specific namespace could solve this issue, but finding a good name is no so simple.

\cpp{bad_expected_access<E>} and \cpp{bad_optional_access} could inherit both from a \cpp{bad_access} exception derived from \cpp{logic_error}, but this is not proposed.


\subsubsection{Getting the contained value on the context of a continuation}
%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Accessing the contained error}
%%%%%%%%%%%%%%%%%%%%%%%

Usually the access to the contained error is done once we know that the expected object has no value. This is why the \cpp{error()} function has a narrow contract, it works only if (\cpp{! *this}).

\begin{lstlisting}
  expected<errc,int> getIntOrZero(istream_range& r);
    auto r = getInt();  // won't throw
    if ( ! r && r.error() == errc::empty_stream ) {
        return 0;
    }
    return r;
  }
\end{lstlisting}

\subsubsection{Conversion to the unexpected value}
%%%%%%%%%%%%%%%%%%

As the \cpp{error()} function the \cpp{get_unexpected()} works only if the expected object has no value. It is used to propagate errors.

\begin{lstlisting}
expected<errc, pair<int, int>> getIntRange(istream_range& r) {
  auto  f = getInt(r);
  if (! f) return f.get_unexpected();

  auto  m = matchedString("..", r);
  if (! m) return m.get_unexpected();

  auto  l = getInt(r);
  if (! l) return l.get_unexpected();

  return std::make_pair(*f, *l);
}
\end{lstlisting}

It is not really necessary as the line 

\begin{lstlisting}
  return f.get_unexpected();
\end{lstlisting}

can be replaced by

\begin{lstlisting}
  return make_unexpected(f.error());
\end{lstlisting}

or even

\begin{lstlisting}
  return expected<errc, pair<int, int>>{unexpect, f.error()};
\end{lstlisting}

However, the function is provided for symmetry purpose. Implicit conversion from \cpp{unexpected<E>} to \cpp{expected<E,T>} and explicit conversion from  \cpp{expected<E,T>} to  \cpp{unexpected<E>}. 

\subsubsection{Function \cpp{has_exception}}
%%%%%%%%%%%%%%%%%%%%%%%%

\cite{AlexandrescuExpected} Expected class has a \cpp{hasException<E>} function that checks if the expected object has a stored exception that derived from \cpp{E}. This function has a sense only when the error parameter is a exception type erased as \cpp{std::exception_ptr} that contains any exception. This function is useful when the user don't needs to get more information than the type of the stored exception.

\begin{lstlisting}
expected<exception_ptr,int> getIntOrZero(istream_range& r) {
    auto r = getInt();  // won't throw
    if (r.has_exception<EmptyStream>() {
        return 0;
    }
    return r;
}
\end{lstlisting}


\subsubsection{Function \cpp{catch_exception}}
%%%%%%%%%%%%%%%%%%

When the user wants to retrieve the whole information on the stored exception the function \cpp{catch_exception}  can be used instead.

\begin{lstlisting}
  expected<exception_ptr,int> getIntOrZero(istream_range& r) 
  {
    return getInt().
    catch_exception<NotANumber>([](auto& ex) // (1)
    {  // has complete access to the stored exception
  
    });   // try to recover
  }
\end{lstlisting}

\cpp{catch_exception<E>} call to the function parameter if the expected instance has no value and the stored exception match the type.

\subsubsection{Function \cpp{value_or}}
%%%%%%%%%%%%%%%%%%

This function template returns a value stored by the \cpp{expected} object if it is valued, and if not, it falls back to the default value specified in the second argument. This method for specifying default values on the fly rather than tying the default values to the type is based on the observation that different contexts or usages require different default values for the same type. For instance the default value for \cpp{int} can be \cpp{0} or \cpp{-1}. The callee might not know what value the caller considers special, so it returns the lack of the requested value explicitly. The caller may be better suited to make the choice what special value to use.

\begin{lstlisting}
expected<exception_ptr,int> queryDB(std::string);
void setPieceCount(int);
void setMaxCount(int);

setPieceCount( queryDB("select piece_count from ...").value_or(0) );
setMaxCount( queryDB("select max_count from ...").value_or(numeric_limits<int>::max()) );
\end{lstlisting}

The decision to provide this function is controversial itself. As pointed out by Robert Ramey, the goal of the optional is to make the lack of the value explicit. Its syntax forces two control paths; therefore we will typically see an if-statement (or similar branching instruction) wherever expected is used. This is considered an improvement in correctness. On the other hand, using the default value appears to conflict with the above idea. One other argument against providing it is that in many cases you can use a ternary conditional operator instead:

\begin{lstlisting}
auto&& cnt = queryDB("select piece_count from ...");
setPieceCount(cnt ? *cnt : 0);

auto&& max = queryDB("select max_count from ...");
setMaxCount(max ? std::move(*max) : numeric_limits<int>::max());
\end{lstlisting}

However, in case expected objects are returned by value and immediately consumed, the ternary operator syntax requires introducing an lvalue. This requires more typing and explicit move. This in turn makes the code less safe because a moved-from lvalue is still accessible and open for inadvertent misuse.

There are reasons to make it a free-standing function. (1) It can be implemented by using only the public interface of optional. (2) This function template could be equally well be applied to any type satisfying the requirements of \cpp{NullableProxy}. In this proposal, function \cpp{value_or} is defined as a member function. Making a premature generalization would risk standardizing a function with suboptimal performance/utility. While we know what detailed semantics (e.g., the return type) \cpp{value_or} should have for \cpp{expected}, we cannot claim to know the ideal semantics for any \cpp{NullableProxy}. Also, it is not clear to us if this convenience function is equally useful for pointers, as it is for optional objects. By making \cpp{value_or} a member function we leave the room for this name in namespace \cpp{std} for a possible future generalization.

The second argument in the function template's signature is not \cpp{T} but any type convertible to \cpp{T}:

\begin{lstlisting}
template <class T, class E, class V> 
  typename T expected<E,T>::value_or(V&& v) const&;
template <class T, class E, class V> 
  typename T expected<E,T>::value_or(V&& v) &&;
\end{lstlisting}

This allows for a certain run-time optimization. In the following example:

\begin{lstlisting}
expected<int, string> ex{"cat"};
string ans = ex.value_or("dog");

Because the expected object is valued, we do not need the fallback value and therefore to convert the string literal "dog" into type \cpp{string}.

It has been argued that the function should return by constant reference rather than value, which would avoid copy overhead in certain situations:

\begin{lstlisting}
void observe(const X& x);

expected<exception_ptr,X> ex { /* ... */ };
observe( ex.value_or(X{args}) );    // unnecessary copy
\end{lstlisting}

However, the benefit of the function \cpp{value_or} is only visible when the optional object is provided as a temporary (without the name); otherwise, a ternary operator is equally useful:

\begin{lstlisting}
expected<exception_ptr,X> ex { /* ... */ };
observe(ox ? *ek : X{args});            // no copy
\end{lstlisting}

Also, returning by reference would be likely to render a dangling reference, in case the expected object is invalid, because the second argument is typically a temporary:

\begin{lstlisting}
expected<exception_ptr,X> ex {};
auto&& x = ex.value_or(X{args});
cout << x;                              // x is dangling!
\end{lstlisting}

There is also one practical problem with returning a reference. The function takes two arguments by reference: the expected object and the default value. It can happen that one is deduced as lvalue reference and the other as rvalue reference. In such case we would not know what kind of reference to return. Returning lvalue reference might prevent move optimization; returning an rvalue reference might cause an unsafe move from lvalue. By returning by value we avoid these problems by requiring one unnecessary move in some cases.

We also do not want to return a constant lvalue reference because that would prevent a copy elision in cases where optional object is returned by value.

As for \cpp{std::experimental::optional<T>} the function \cpp{expected<E,T>::value_or<V>} could return type \cpp{decay_t<common_type_t<T, V>} rather than \cpp{T}. This would avoid certain problems, such as loss of accuracy on arithmetic types:

\begin{lstlisting}
// not proposed
expected<E,int> op = /* ... */;
long gl = /* ... */;

auto lossless = op.value_or(gl);   // lossless deduced as long rather than int
\end{lstlisting}

However, to be alined with \cpp{std::experimental::optional<T>}  we do not propose it at this time.

Together with function \cpp{value}, \cpp{value_or} makes a set of similarly called functions for accessing the contained value that do not cause an undefined behavior when invoked on a invalid expected (at the expense of runtime overhead). They differ though, in the return type: one returns a value, the other a reference.

\subsubsection{Relational operators}
%%%%%%%%%%%%%%%%%%

As \cpp{optional}, one of the design goals of \cpp{expected} is that objects of type \cpp{expected<E,T>} should be valid elements in STL containers and usable with STL algorithms (at least if objects of type \cpp{T} and \cpp{E} are). Equality comparison is essential for \cpp{expected<E,T>} to model concept \cpp{Regular}. C++ does not have concepts, but being regular is still essential for the type to be effectively used with STL. Ordering is essential if we want to store expected values in ordered associative containers. A number of ways of including the unexpected state in comparisons have been suggested. The ones proposed, have been crafted such that the axioms of equivalence and strict weak ordering are preserved: unexpected values stored in \cpp{expected<E,T>} are simply treated as additional values that are always different from \cpp{T}; these values are always compared as less than any value of \cpp{T} when stored in an expected object. 
   
The main issue is how to compare the unexpected values between them.  \cpp{operator==()} is defined for \cpp{exception_ptr}, using shallow semantics but there is no order between two \cpp{exception_ptr}.

\begin{lstlisting}
template <class T, class E>
constexpr bool operator<(const expected<E,T>& x, const expected<E,T>& y)
{
  return (x)
       ? (y) ? *x < *y : false
       : (y) ? true : ?<?;
}

template <class T, class E>
constexpr bool operator==(const expected<E,T>& x, const expected<E,T>& y)
{
    return (x)
         ? (y) ? *x == *y : false
         : (y) ? false : ?==?;
}
\end{lstlisting}

If we follow the \cpp{optional<T>} semantics, two unexpected values should always be equal and do not compare. That is, \cpp{?<?} should be substituted by \cpp{false} and \cpp{?==?} by \cpp{true}. However considering all the unexpected value equals seems counterintuitive.

The alternative consists in forwarding the request to the respective  \cpp{unexpected_type<E>} relational operators. That is, \cpp{?<?} should be substituted by \cpp{x.get_unexpected() < y.get_unexpected()} and \cpp{?==?} by \cpp{x.get_unexpected() == y.get_unexpected()}. 

But how to define the relational operators for \cpp{unexpected_type<E>}? We can forward the request to the respective \cpp{E} relational operators when \cpp{E} defines these operators and follows the \cpp{optional<T>} semantics otherwise. 

The case of \cpp{unexpected_type<std::exception_ptr>} could follow the \cpp{optional<T>} semantics as the shallow comparison is not very useful.

This limitation is one of the main motivations for having a user defined type with strict weak ordering. E.g. if the user know the exact types of the exceptions that can be thrown \cpp{E1}, ..., \cpp{En}, the error parameter could be some kind of \cpp{variant<E1, ... En>} for which a strict weak ordering can be defined. If the user would like to take care of unknown exceptions something like \cpp{optional<variant<E1, ... En>>} would be a quite appropriated model. 

\begin{lstlisting}
expected<int, unsigned> e0{0};
expected<int, unsigned> e1{1};
expected<int, unsigned> eN{unexpect, -1};

assert (eN < e0);
assert (e0 < e1);
assert (!(eN  < eN));
assert (!(e1 < e1));

assert (eN != e0);
assert (e0 != e1);
assert (eN == eN);
assert (e0 == e0);
\end{lstlisting}

Unexpected values could have been as well considered greater than any value of \cpp{T}. The choice is a great degree arbitrary. We choose to stick to what \cpp{std::optional} does.

Given that both \cpp{unexpected_type<E>} and \cpp{T} are implicitly convertible to \cpp{expected<E,T>}, this implies the existence and semantics of mixed comparison between \cpp{expected<E,T>} and \cpp{T}, as well as between \cpp{expected<E,T>} and \cpp{unexpected_type<E>}:

\begin{lstlisting}
assert (eN == make_unexpected(1));
assert (e0 != make_unexpected(1));
assert (eN != 1);
assert (e1 == 1);

assert (eN < 1);
assert (e0 > make_unexpected(1));
\end{lstlisting}

Although it is difficult to imagine any practical use case of ordering relation between \cpp{expected<E,T>} and \cpp{unexpected_type<E>}, we still provide it for completness sake.

The mixed relational operators, especially these representing order, between \cpp{expected<E,T>} and \cpp{T} have been accused of being dangerous. In code examples like the following, it may be unclear if the author did not really intend to compare two \cpp{T}'s.

\begin{lstlisting}
auto count = get_expected_count();
if (count < 20) {}                        // or did you mean: *count < 20 ?
if (! count || *count < 20) {}   // verbose, but unambiguous
\end{lstlisting}

Given that \cpp{expected<E,T>} is comparable and implicitly constructible from \cpp{T}, the mixed comparison is there already. We would have to artificially create the mixed overloads only for them to cause controlled compilation errors. A consistent approach to prohibiting mixed relational operators would be to also prohibit the conversion from \cpp{T} or to also prohibit homogenous relational operators for \cpp{expected<E,T>} ; we do not want to do either, for other reasons discussed in this proposal. Also, mixed relational operations are available in \cpp{std::optional<T>} and we want to maintain the same behavior for \cpp{expected<nullopt_t,T>} and \cpp{optional<T>}. Mixed operators come as something natural when we consider the model "T with additional values".

For completeness sake, we also provide ordering relations between  \cpp{expected<E,T>} and  \cpp{unexpected_type<E>}, even though we see no practical use case for them:

\begin{lstlisting}
bool test(expected<unsigned, int> e)
{
  assert (e >= make_unexpected(1));    
  assert (!(e < make_unexpected(1)));  
  assert (make_unexpected(1) <= e);    
  return (e > make_unexpected(1));     
}
\end{lstlisting}

There exist two ways of implementing \cpp{operator>()} for expected objects: use \cpp{T::operator>()} or use \cpp{expected<E,T>::operator<()}

In case \cpp{T::operator>} and \cpp{T::operator<} are defined consistently, both above implementations are equivalent. If the two operators are not consistent, the choice of implementation makes a difference. 

For relational operations, we choose to implement all in terms of  \cpp{expected<E,T>::operator<()} to be consistent with the choice taken for \cpp{std::optional}.

The same applies to the relational operators for \cpp{unexpected_type<E>} .

\subsection{Modifiers}
%%%%%%%%%%%%%%%%%%

\subsubsection{Reseting the value}
%%%%%%%%%%%%%%%%%%

Assigning the value of type \cpp{T} to \cpp{expected<E,T>} object results in doing two different things based on whether the expected object has a value or not. If expected object has a value, the contained value is assigned a new value. If expected object has an unexpected value, the destructor of the unexpected value is called and then it becomes valued using \cpp{T}'s copy/move constructor. This behavior is based on a silent assumption that \cpp{T}'s copy/move constructor is copying a value in a similar way to copy/move assignment. A similar logic applies to \cpp{expected<E,T>}'s copy/move assignment, although the situation here is more complicated because we have two valued/unexpected states to be considered. This means that \cpp{expected<E,T>}'s assignment does not work (does not compile) if \cpp{T} is not assignable:

\begin{lstlisting}
expected<int,const int> ei = 1;  // ok
ei = 2;                      // error 
ei = ei;                     // error 
ei = make_unexpected(1);                // ok
\end{lstlisting}

There is an option to reset the value of optional object without resorting to \cpp{T}'s assignment:

\begin{lstlisting}
expected<int, const int> ej = 1;  // ok
ej.emplace(2);               // ok 
\end{lstlisting}

Function emplace disengages the optional object if it is engaged, and then just engages the object anew by copy-constructing the contained value. It is similar to assignment, except that it is guaranteed not to use T's assignment and provides only a basic exception safety guarantee. In contrast, assignment may provide a stronger guarantee if T's assignment does.

To sumarize, this proposal offers three ways of assigning a new contained value to an optional object:

\begin{lstlisting}
optional<int> e;
e = make_optional(1);         // copy/move assignment
e = 1;                        // assignment from T
e.emplace(1);                 // emplacement 
\end{lstlisting}

The first form of assignment is required to make optional a regular object, useable in STL. We need the second form in order to reflect the fact that optional<T> is a wrapper for T and hence it should behave as T as much as possible. Also, when optional<T> is viewed as T with one additional value, we want the values of T to be directly assignable to optional<T>. In addition, we need the second form to allow the interoperability with function std::tie as shown above. The third option is required to be able to reset an optional non-assignable T.

\subsubsection{Tag \cpp{in_place}}
%%%%%%%%%%%%%%%%%%

This proposal makes use of the 'in-place' tag defined in \cite{OptionalRev5}. This proposal  provides the same kind of 'in-place' constructor that forwards (perfectly) the arguments provided to \cpp{expected}'s constructor into the constructor of \cpp{T}. In order to trigger this constructor one has to use the tag struct \cpp{in_place}. We need the extra tag to disambiguate certain situations, like calling \cpp{expected}'s default constructor and requesting \cpp{T}'s default construction:

\begin{lstlisting}
expected<int,Big> eb{in_place, "1"}; // calls Big{"1"} in place (no moving)
expected<int,Big> ec{in_place};      // calls Big{} in place (no moving)
expected<int,Big> ed{};             // creates a unexpected expected
\end{lstlisting}


\subsubsection{Tag \cpp{unexpect}}
%%%%%%%%%%%%%%%%%%

This proposal provides an 'unpect' constructor that forwards (perfectly) the arguments provided to \cpp{expected}'s constructor into the constructor of \cpp{E}. In order to trigger this constructor one has to use the tag struct \cpp{unexpect}. We need the extra tag to disambiguate certain situations, like calling \cpp{expected}'s default constructor and requesting \cpp{T}'s default construction:

\begin{lstlisting}
expected<int, Big> eb{unexpect, "1"}; // calls Big{"1"} in place (no moving)
expected<int, Big> ec{unexpect};      // calls Big{} in place (no moving)
\end{lstlisting}

In order to make the tag uniform an additional 'expect' constructor could be provided but this proposal doesn't propose it.

\subsubsection{Requirements}

The \cpp{expected<std::exception_ptr,T>} specialization introduces some operations as \cpp{has_exception} and \cpp{catch_exception}. Should we name the classes differently? For example, \cpp{exception_or<T>} and \cpp{error_or<E,T>}.

\subsubsection{Requirements on \cpp{T} and \cpp{E}}
%%%%%%%%%%%%%%%%%%

Class template \cpp{expected} imposes little requirements on \cpp{T} and \cpp{E}: they have to be  complete object type satisfying the requirements of \cpp{Destructible}. It is the particular operations on \cpp{expected<E,T>} that impose requirements on \cpp{T} and \cpp{E}: \cpp{expected<E,T>}'s move constructor requires that \cpp{T} and \cpp{E} are \cpp{MoveConstructible}, \cpp{expected<E,T>}'s copy constructor requires that \cpp{T} and \cpp{E} are \cpp{CopyConstructible}, and so on. This is because \cpp{expected<E,T>} is a wrapper for \cpp{T} or \cpp{E}: it should resemble \cpp{T} as much as possible. If \cpp{T} is \cpp{EqualityComparable} then (and only then) we expect \cpp{expected<E,T>} to be \cpp{EqualityComparable}. 


\subsubsection{Expected references}
%%%%%%%%%%%%%%%%%%

This proposal doesn't include expected references as \cite{optional} doesn't  includes optional references neither.

\subsubsection{Expected void}
%%%%%%%%%%%%%%%%%%

While it could seem weird to instantiate optional with \cpp{void}, it has more sense for expected as expected conveys in addition, as \cpp{future<T>},  an error code, \cpp{expected<E,void>}.

\subsubsection{\cpp{NullableProxy}}
%%%%%%%%%%%%%%%%%%

As optional objects, the primary purpose of expected object is to check if they contain a value and if so, to provide access to this value.  \cpp{expected<E,T>} could be seen also as a \cpp{NullableProxy}.  

\subsection{Literals}

\subsubsection{Making \cpp{expected} a literal type}
%%%%%%%%%%%%%%%%%%

We propose that \cpp{expected<E,T>} be a literal type for trivially destructible \cpp{T}'s and \cpp{E}'s.

\begin{lstlisting}
constexpr expected<int, int> ei{5};
static_assert(ei, "");            // ok
static_assert(ei == ei, "");      // ok
int array[*ei];                   // ok: array of size 5 
\end{lstlisting}

Making \cpp{expected<E,T>} a literal-type in general is impossible: the destructor cannot be trivial because it has to execute an operation that can be conceptually described as:

~expected() {
  if (valid()) destroy_contained_value();
  else destroy_contained_error();
}

It is still possible to make the destructor trivial for \cpp{T}'s and \cpp{E}'s which provide a trivial destructor themselves, and we know an efficient implementation of such  \cpp{expected<E,T>}  with compile-time interface ? except for copy constructor and move constructor ? is possible. Therefore we propose that for trivially destructible \cpp{T}'s and \cpp{E}'s all \cpp{expected<E,T>}'s constructors, except for move and copy constructors, as well as observer functions are constexpr. The sketch of reference implementation is provided in \cite{boost.expected}.

We need to make a similar exception for \cpp{operator->} for types with overloaded \cpp{operator&}. The common pattern in the library is to use function \cpp{addressof} to avoid the surprise of overloaded \cpp{operator&}. However, we know of no way to implement constexpr version of function template addressof. The best approach we can take is to require that for normal types the non-overloaded (and constexpr) \cpp{operator&} is used to take the address of the contained value, and for the tricky types, implementations can use the normal (non-constexpr) \cpp{addressof}. 

\subsubsection{Moved from state}
%%%%%%%%%%%%%%%%%%

When a valued expected object is moved from (i.e., when it is the source object of move constructor or move assignment) its state does not change. When a valued object is moved from, we move the contained value, but leave the expected object valued. A moved-from contained value is still valid (although possibly not specified), so it is fine to consider such expected object valued. An alternative approach would be to destroy the contained value and make the moved-from optional object unvalid. However, we do not propose this for performance reasons.

In contexts, like returning by value, where you need to call the destructor the second after the move, it does not matter, but in cases where you request the move explicitly and intend to assign a new value in the next step, and if \cpp{T} does not provide an efficient move, the chosen approach saves an unnecessary destructor and constructor call:

\begin{lstlisting}
expected<errc,array<Big, 1000>> eo = ... // array doesn't have efficient move
ep = std::move(eo);
eo = std::move(tmp);
\end{lstlisting}

The following is an even more compelling reason. In this proposal \cpp{expected<int,int>} is allowed to be implemented as a TriviallyCopyable type. Therefore, the copy constructor of type \cpp{std::array<expected<int,int>, 1000>} can be implemented using \cpp{memcpy}. With the additional requirement that expected's move constructor should not be trivial, we would be preventing the described optimization.

The fact that the moved-from expected is not invalid may look "uncomfortable" at first, but this is an invalid expectation. The requirements of library components expressed in 17.6.5.15 (moved-from state of library types) only require that moved-from objects are in a valid but unspecified state. We do not need to guarantee anything above this minimum.

\subsection{Expected traits}
\label{expected-traits-rational}

\subsection{Other}

\subsubsection{IO operations}
%%%%%%%%%%%%%%%%%%

The proposed interface for expected values does not contain IO operations: \cpp{operator<<} and \cpp{operator>>}. While we believe that they would be a useful addition to the interface of expected objects, we also observe that there are some technical obstacles in providing them, and we choose not to propose them at this time. Library components like optional, containers, pairs, tuples face the same issue. At present IO operations are not provided for these types. Our preference for \cpp{expected} is to provide an IO solution compatible with this for optional, containers, pairs and tuples, therefore at this point we refrain from proposing a solution for \cpp{expected} alone.


\subsubsection{Function \cpp{make_expected}}
%%%%%%%%%%%%%%%%%%

\subsection{Monad-like operations}
%%%%%%%%%%

\cite{ImprovementsAsync} propose some improvements to \cpp{std::future<T>} that can be adapted to \cpp{expected<E,T>} naturally.

\subsubsection{When ready}
%%%%%%%%%%

\cite{ImprovementsAsync} provides a \cpp{future<T>.then()} function that accepts a continuation having the future object as parameter. This continuation function is called when the future becomes ready. Been expected always ready this function is less useful. The single role would be to adapt the result of the continuation to the expected.

\subsubsection{When valued/unexpected}
%%%%%%%%%%

In addition the \cpp{.then()} function that accepts a continuation having the expected object as parameter, the proposal includes two separated functions, one \cpp{.bind()} that applies when the expected object is valued and accepts a continuation having the underlying \cpp{value_type} as parameter. The other \cpp{.catch_error()} applies when the expected object is not valid and is used to try to recover from the error.  

\subsubsection{Continuation adaptors}
%%%%%%%%%%

An alternative to these specific functions could be to use the \cpp{.then()} function and have some adaptor \cpp{if_valued} and \cpp{if_unexpected} that do the adaptation.

\begin{lstlisting}
f.then(if_valued([](T v) {...}));

f.then(if_unexpected([](E e) {...}));
\end{lstlisting}

TBoost.Expected \cite{boost_expected} provides such a \cpp{.then} continuation adaptors, but this proposal doesn't include them.

\subsubsection{\cpp{value_or_call}}
%%%%%%%%%%

As reported in \cite{OPTIONAL_R5} one  convenience function has been suggested. Sometimes the default value is not given, and computing it takes some time. We only want to compute it, when we know the optional object is disengaged:

\begin{lstlisting}
expected<exception_ptr,int> ei = /* ... */;

if (ei) {
  use(*ei);
}
else {
  int i = painfully_compute_default();
  use(i);
}
\end{lstlisting}

The solution to that situation would be another convenience function which rather than taking a default value takes a callable object that is capable of computing a default value if needed:

\begin{lstlisting}
use( ei.value_or_call(&painfully_compute_default) );       
// or
use( ei.value_or_call([&]{return painfully_compute_default();} );
\end{lstlisting}

This is quite close to the context of use of  \cpp{catch_error}, but the function called has no parameter. As there is an alternative using generic lambdas this proposal doesn't propose neither this function.

\begin{lstlisting}
ei.catch_error([](auto){ return painfully_compute_default();}).bind(use);       
\end{lstlisting}

\subsubsection{When all ready}
%%%%%%%%%%

 \cite{ImprovementsAsync} includes \cpp{when_all()/when_any()//when_any_swaped()} functions to group futures on a new specific future that will be ready under different circumstances. As \cpp{expected<E,T>} is always ready, these functions have no sense. If provided the result and the behavior would be the same for both, just group all the expected.  
 
\subsubsection{When all valued}
%%%%%%%%%%

However, there is yet a need to apply a function when all the expected are valued. The free function \cpp{map()} takes a variadic continuation and a variadic number of expected parameters. The type and number of the parameters must be compatible with the continuation arguments.

\begin{lstlisting}
 expected<exception_ptr,int> sumFirstAndSecond5(istream_range& r)
{
  return map(plus, getInt(r), getInt(r));
}
\end{lstlisting}

An alternative to this specific function if \cpp{when_all} is provided, could be to use the \cpp{.then()} function and have some adaptor \cpp{if_all_valued} that do the adaptation.

\begin{lstlisting}
expected<exception_ptr,int> sumFirstAndSecond5(istream_range& r)
{
  return when_all(getInt(r), getInt(r)).then(if_all_valued([](int i, int j) {...}));
}
\end{lstlisting}

\subsubsection{When any valued}
%%%%%%%%%%

The authors don't have a concrete use case for a function that would be applied if any of the expected has a value other than looking for non-determinism.

\subsubsection{\cpp{expected<E, expected<E,T>>}}
%%%%%%%%%%


\subsubsection{Function \cpp{unwrap}}
%%%%%%%%%%

In some scenarios, you might want to create an \cpp{expected} that returns another \cpp{expected}, resulting in nested expected. 
It is possible to write simple code to unwrap the outer \cpp{expected} and retrieve the nested \cpp{expected} and its result with the current interface as in

\begin{lstlisting}
template <class T, class E>
expected<E,T> unwrap<expected<E, expected<E,T>> ee) {
  if (ee) return *ee;
  return ee.get_unexpected();
}
template <class T, class E>
expected<E,T> unwrap<expected<E,T>> e) {
  return e;
}
\end{lstlisting}

We could add such a function to the standard, either as a free function or as a member function. The authors propose to add it as a member function to be inline with \cite{ImprovementsAsync}.

\section{Related types}
%%%%%%%%%%%

\subsection{Variant}
%%%%%%%%%%%%%%%%%%%%

\cpp{expected<E,T>} can be seen as a specialization of  \cpp{boost::variant<unexpected<E>,T>} which gives a specific intent to its second parameter, that is, it represent the type of the expected contained value. This specificity allows to provide a pointer like interface, as it is the case for \cpp{std::experimental::optional<T>}. Even if the standard included a class  \cpp{variant<T,E>}, the interface provided by \cpp{expected<E,T>} is more specific and closer to what the user could expect as the result type of a function. In addition, \cpp{expected<E,T>} doesn't intend to be used to define recursive data as \cpp{boost::variant<>} does.

The table \ref{comp-variant} presents a brief comparison between \cpp{boost::variant<T, E>} and \cpp{expected<E,T>}.

\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}
{|l|>{\raggedright\arraybackslash}p{6cm}|>{\raggedright\arraybackslash}p{6cm}|}
\hline
                    & \textbf{boost::variant<unexpected<E>, T>} & \textbf{expected<E,T>}  \\
\hline
\textbf{never-empty warranty} & yes & yes \\
\hline
\textbf{accepts is_same<T,E>} & no & yes \\
\hline
\textbf{swap} & yes & yes \\
\hline
\textbf{factories} & no & make\_expected / make\_unexpected  \\
\hline
\textbf{hash} & yes & yes  \\
\hline
\textbf{value_type} & no & yes  \\
\hline
\textbf{default constructor} & yes (if T is default constructible) & yes (if T is default constructible)  \\
\hline
\textbf{observers} & boost::get<T> and boost::get<E> & pointer-like / value / error / value_or / value_or_throw \\
\hline
\textbf{continuations} & apply_visitor & then/bind/catch_error  \\
\hline
\end{tabular}
\egroup
\caption{Comparison between variant and expected.}
\label{comp-variant}
\end{table}


\subsection{Optional}
%%%%%%%%%%%

We can see \cpp{expected<E,T>} as an \cpp{std::experimental::optional<T>} that collapse all the values of \cpp{E} to \cpp{nullopt}. 

We can convert an \cpp{expected<E,T>} to an \cpp{optional<T>} with the possible loss of information.

\begin{lstlisting}
template <class T>
optional<T> make_optional(expected<E,T> v) {
  if (v) return make_optional(*v);
  else nullopt;
}
\end{lstlisting}

We can convert an \cpp{optional<T>} to an \cpp{expected<exception_ptr,T>} without knowledge of the root cause.

\begin{lstlisting}
template <class T>
expected<exception_ptr,T> make_expected(optional<T> v) {
  if (v) return make_expected(*v);
  else make_unexpected(conversion_from_nullopt());
}
\end{lstlisting}

\subsection{Promise and Future}
%%%%%%%%%%%%%%%%%

We can see \cpp{expected<exception_ptr,T>} as a always ready \cpp{future<T>}.
While \cpp{promise<>}/\cpp{future<>} focuses on inter-thread asynchronous communication, \cpp{excepted<E,T>} focus on eager and synchronous computations.
We can move a ready \cpp{future<T>} to an \cpp{expected<exception_ptr,T>} with no loss of information. 

\begin{lstlisting}
template <class T>
expected<exception_ptr,T> make_expected(future<T>&& f) {
  assert (f.ready() && "future not ready");
  try {
    return f.get();
  } catch (...) {
    return make_unexpected_from_exception();
  }
}
\end{lstlisting}

We can create also a \cpp{future<T>} from an \cpp{expected<exception_ptr,T>}.

\begin{lstlisting}
template <class T>
future<T> make_ready_future(expected<exception_ptr,T> e) {
  if (e) 
    return make_ready_future(*e);
  else 
    return make_unexpected_future<T>(e.error()); 
}
\end{lstlisting}

where

\begin{lstlisting}
template <class T, class E>
constexpr future<T> make_unexpected_future(E e)  {
  promise<T> p;
  future<T> f = p.get_future();
  p.set_exception(e);
  return move(f);
}
\end{lstlisting}

We can combine them as follows

\begin{lstlisting}
fut.then([](future<int> f) { 
  return make_ready_future(
    make_expected(f).bind([](i){ ... }).catch_error(...));
  });
\end{lstlisting}

\subsection{Expected monad}
%%%%%%%%%%%%%%%

As for the \cpp{future<T>} proposal, \cpp{expected<E,T>} provides also a way to visit the stored values.
\cpp{future<T>} provides a \cpp{then()} function that accepts a continuation having the \cpp{future<T>} as parameter. The synchronous nature of expected makes it easier to use two functions, one to manage with the case expected has a value and one to try to recover otherwise. This is more in line with the monad interface, as any function having a \cpp{T} as parameter can be used as parameter of the apply function, no need to have a \cpp{expected<E,T>}. This make it easier to reuse functions. 

\begin{itemize}
 \item \cpp{expected<E,T>::bind()}/\cpp{expected<E,T>::catch_error()} are the counterpart of \cpp{future<T>.then()}
 \item \cpp{expected<E,T>::unwrap()} is the counterpart of \cpp{future<T>.unwrap()}
 \item \cpp{expected<E,T>::operator bool()} is the counterpart of \cpp{future<T>.has_value()}
\end{itemize}

\subsection{Comparison between optional, expected and future}

The table \ref{comp-monads} presents a brief comparison between \cpp{optional<T>}, \cpp{expected<E,T>}  and \cpp{promise<T>/future<T>}.

\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|}
\hline
                    & \textbf{optional} & \textbf{expected} & \textbf{promise/future} \\
\hline
\textbf{specific null value} & yes & no & no \\
\hline
\textbf{relational operators} & yes & yes & no \\
\hline
\textbf{swap} & yes & yes & yes \\
\hline
\textbf{factories} & make_optional / nullopt & make_expected / make_unexpected & make_ready_future / (make_exceptional, see \cite{MoreAsync}) \\
\hline
\textbf{hash} & yes & yes & yes \\
\hline
\textbf{value_type} & yes & yes & no / (yes, see \cite{MoreAsync}).  \\
\hline
\textbf{default constructor} & yes & yes (if T is default constructible) & yes \\
\hline
\textbf{allocators} & no & no & yes \\
\hline
\textbf{emplace} & yes & yes & no \\
\hline
\textbf{bool conversion} & yes & yes & no \\
\hline
\textbf{state} & bool()  &  bool() & valid / ready / (has_value, see \cite{MoreAsync}) \\
\hline
\textbf{observers} & pointer-like / value / value_or & pointer-like / value / error / value_or / value_or_throw & get / (get_exception_ptr, see \cite{MoreAsync}) \\
\hline
\textbf{visitation} & no & then/bind/catch_error  & then / (next/recover see \cite{MoreAsync}) \\
\hline
\textbf{grouping} & n/a & n/a & when_all / when_any \\
\hline
\textbf{apply} & no & bind & no \\
\hline
\end{tabular}
\egroup
\caption{Comparison between optional, expected and promise/future.}
\label{comp-monads}
\end{table}

\section{Open points}
%%%%%%%%%%%%%

\subsection{Better support for monad}
\label{better-support-for-monad}

A cleaner solution uses the variadic free function \cpp{map}\footnote{\cpp{map} stands for ``functor map''.}:

\begin{lstlisting}
expected<exception_ptr,int> f(int i, int j, int k)
{
  return map(plus,
    safe_divide(i, k), 
    safe_divide(j, k));
}
\end{lstlisting}

The function \cpp{map} returns the first erroneous expected argument or, if they all contain a value, the result of the \cpp{plus} operation.


Now let's rewrite this using a possible C++ language extension: adding a DO expression like the Haskell do expression. It is something similar  to the \cpp{await} extension for futures however it is not limited to futures. It could works for any monad.   

The grammar could be

\begin{lstlisting}
do-expression ::= do-initialization ':' do-expression-or-expression

do-expression-or-expression ::= do-expression | expression

do-initialization ::= type var '<-' expression
\end{lstlisting}

The meaning of \cpp{do-expression}  is given by a transformation \cpp{[[ ]]}

\begin{lstlisting}
[[do-expression]] =
  bind(expression,[&](type var) {
    return [[do-expression-or-expression]]
  });
\end{lstlisting}

The previous function could be written as

\begin{lstlisting}
expected<exception_ptr,int> f2(int i, int j, int k)
{
  return (
    auto s1 <- safe_divide(i, k) :
    auto s2 <- safe_divide(j, k) :
    s1 + s2
  );
}
\end{lstlisting}

resulting in the transformed C++ code

\begin{lstlisting}
expected<exception_ptr,int> f2(int i, int j, int k)
{
  return bind(safe_divide(i, k) ,[&r](auto s1) {
    return bind(safe_divide(j, k),[&r](auto s2) {
      return s1 + s2;
    });
  }); 
}
\end{lstlisting}

This would give the exact same results as the previous version. However, the function \cpp{f2} is much simpler and clearer than \cpp{f} because it doesn't have to explicitly handle any of the error cases. When an error case occurs, it is returned as the result of the function, but if not, the correct result of a subexpression is bound to a name (\cpp{s1} or \cpp{s2}), and that result can be used in later parts of the computation. The code is a lot simpler to write. The more complicated the error-handling function, the more important this will be.

But, the standard doesn't have this DO expression yet.
Waiting for a do-statement the user could define some macros (see \cite{monad_do_poc} and define \cpp{f2} as

\begin{lstlisting}
expected<exception_ptr,int> f2(int i, int j, int k)
{
    return DO (
         ( s1, safe_divide(i, k) )
         ( s2, safe_divide(j, k) )
         s1 + s2 
    );
}
\end{lstlisting}

In the case of expected and optional, that is, monads that are always ready and have only one value stored, the following macro 

\begin{lstlisting}
#define EXPECT(V, EXPR) \
auto BOOST_JOIN(expected,V) = EXPR; \
if (! has_value(BOOST_JOIN(expected,V))) return get_unexpected(BOOST_JOIN(expected,V)); \
auto V = deref(BOOST_JOIN(expected,V))
\end{lstlisting}

can be used to obtain the same result.

\begin{lstlisting}
expected<exception_ptr,int> f2(int i, int j, int k)
{
  EXPECT(s1, safe_divide(i, k) );
  EXPECT(s2, safe_divide(j, k));
  return s1 + s2;
}
\end{lstlisting}

Note that this meaning of EXPECT is not valid for the list monad. 

\subsection{Allocator support}
%%%%%%%%%%%%%%%

As \cpp{optional<T>},  \cpp{expected<E,T>} does not allocate memory. So it can do without allocators. However, it can be useful in compound types like:

\begin{lstlisting}
typedef vector< expected<erroc, vector<int, MyAlloc>>, MyAlloc>; MyVec;
MyVec v{ v2, MyAlloc{} };
\end{lstlisting}

One could expect that the allocator argument is forwarded in this constructor call to the nested vectors that use the same allocator. Allocator support would enable this. \cpp{std::tuple} offers this functionality.

\subsection{Which exception throw when the user try to get the expected value but there is none?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested to let the user decide the Exception that would be throw when the user try to get the expected value but there is none, as third parameter. 

While there is no major complexity doing it, as it just needs a third parameter that could default to the appropriated class, 

\begin{lstlisting}
template <class T, class Error, class Exception = bad_expected_access>
  struct expected;
\end{lstlisting}

the authors consider that this is not really needed and that this parameter should not really be part of the type. In addition \cpp{OPTIONAL}

The user can use \cpp{value_or_throw()} as

\begin{lstlisting}
std::experimental::expected<std::error_code, int> f();
std::experimental::expected<std::error_code, int> e = f();
auto i = e.value_or_throw<std::system_error>();  
\end{lstlisting}

The user can also wrap the proposed class in its own expected class

\begin{lstlisting}
template <class T, class Error=std::error_code, class Exception=std::system_error>
struct MyExpected {
  expected <T,E> v;
  MyExpected(expected <T,E> v) : v(v) {}
  T value() {  
    if (e) return v.value();
    else throw Exception(v.error());
  }
  ...
};
\end{lstlisting}

and use it as

\begin{lstlisting}
std::experimental::expected<std::error_code, int> f();
MyExpected<int> e = f();
auto i = e.value();  // std::system_error throw if not valid
\end{lstlisting}

A class like this one could be added to the standard, but this proposal doesn't request it. 

An alternative could be to add a specialization on a error class that gives the storage and the exception to thrown.

\begin{lstlisting}
template <class Error, class Exception>
  struct error_exception {
    typedef Error error_type;
    typedef Exception exception_type;
  };
\end{lstlisting}

\begin{lstlisting}
std::experimental::expected<std::error_exception<std::error_code, std::system_error>, T> e = make_unexpected(err);
e.value(); // will thow std::system_error(err);
\end{lstlisting}


\subsection{About \cpp{expected<T, ErrorCode, Exception>}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It has been suggested also to extend the design into something that contains 

\begin{itemize}
\item a T, or
\item an error code, or
\item a \cpp{exception_ptr} 
\end{itemize}

Again there is no major difficulty to implement it, but instead of having one variation point we have two, that is, is there a value, and if not, if is there an exception_ptr. While this would need only an extra test on the exceptional case, the authors think that it is not worth doing it as all the copy/move/swap operations would be less efficient. 

%%%%%%%%%%%%%%
\section{Proposed Wording}
%%%%%%%%%%%%%%


The proposed changes are expressed as edits to N3908, the Working Draft - C++ Extensions for Library Fundamentals \cite{FundamentalsV1}. The wording has been adapted from the section  "Optional objects".
\newline

Insert a new section. 

\wordingSec{Unexpected objects}{unexpected}
%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{In general}{unexpected.general}
%%%%%%%%%%%%%%%%%%%%%%%%

This subclause describes class template \cpp{unexpected_type} that wraps objects intended as unexpected. This wrapped unexpected object is used to be implicitly convertible to other object.

\wordingSubSec{Header <experimental/unexpected> synopsis}{unexpected.synop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
  // \ref{unexpected.object}, Unexpected object type
  template <class E>
  struct unexpected_type; 
  // \ref{unexpected.exception_ptr}, Unexpected exception_ptr specialization
  template <>
  struct unexpected_type<exception_ptr>; 

  // \ref{unexpected.factories}, Unexpected factories
  template <class E>
  constexpr unexpected_type<decay_t<E>> make_unexpected(E&& v);
  unexpected_type<std::exception_ptr> make_unexpected_from_current_exception();
}}}
\end{lstlisting}

A program that necessitates the instantiation of template \cpp{unexpected} for a reference type or \cpp{void} is ill-formed.

\wordingSubSec{Unexpected object type}{unexpected.object}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unexpected_type object type
\begin{lstlisting}
template <class E=std::exception_ptr>
class unexpected_type {
public:
    unexpected_type() = delete;
    constexpr explicit unexpected_type(E const&);   
    constexpr explicit unexpected_type(E&&);
    constexpr E const& value() const;                              
}; 
\end{lstlisting}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E const&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by copying the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type move constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E &&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by moving the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr E const& value() const;                              
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
A const reference to the stored error.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Unexpected exception_ptr specialization}{unexpected.exception_ptr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <>
class unexpected_type<std::exception_ptr> {
public:
    unexpected_type() = delete;
    explicit unexpected_type(std::exception_ptr const&);
    explicit unexpected_type(std::exception_ptr&&);
    template <class E>
      explicit unexpected_type(E);     
    std::exception_ptr const &value() const;                              
}; 
\end{lstlisting}
\noindent

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(exception_ptr const&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by copying the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type move constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(exception_ptr &&);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected by moving the parameter to the internal storage.
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from an Exception.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr explicit unexpected_type(E e);   
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Build an unexpected storing the result of make_exception_ptr(e).
\end{wordingTextItem}
\end{wordingPara}

% unexpected_type constructor from underlying.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    constexpr exception_ptr const& value() const;                              
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
A const reference to the stored \cpp{exception_ptr}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Factories}{unexpected.factories}

% make_unexpected  factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class E>
constexpr unexpected_type<decay_t<E>> make_unexpected(E&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{unexpected<decay_t<E>>(v)}.
\end{wordingTextItem}
\end{wordingPara}

% make_unexpected  factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr unexpected_type<std::exception_ptr> make_unexpected_from_current_exception();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{unexpected<std::exception_ptr>(std::current_exception())}.
\end{wordingTextItem}
\end{wordingPara}

Insert a new section.

\wordingSec{Expected objects}{expected}
%%%%%%%%%%%%%%%%%%%%%

\wordingSubSec{In general}{expected.general}
%%%%%%%%%%%%%%%%%%%%%%%%

This subclause describes class template expected that represents expected objects. An expected object for object type T is an object that contains the storage for another object and manages the lifetime of this contained object T, alternatively it could contain the storage for another unexpected object E. The contained object may not be initialized after the expected object has been initialized, and may not be destroyed before the expected object has been destroyed. The initialization state of the contained object is tracked by the expected object.

\wordingSubSec{Header <experimental/expected> synopsis}{expected.synop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
  // \ref{expected.holder}, holder class used as default.  
  class holder;
  // \ref{expected.object}, expected for object types  
  template <class E= exception_ptr, class T=holder>
  class expected;
  // \ref{expected.object.void}, Specialization for void.  
  template <class E>
  class expected<E, void>;
  // \ref{expected.object.meta}, Specialization of expected as a meta-function : T-> expected<E,T>.  
  template <class E>
  class expected<E, holder>;
   
  // \ref{expected.unexpect}, unexpect tag
  struct unexpect_t{};
  constexpr unexpet_t unexpect{};
   
  // \ref{expected.bad_expected_access}, class bad_expected_access
  class bad_expected_access;
  
  // \ref{expected.expected_default_constructed}, class expected_default_constructed
  class expected_default_constructed;
  
  // \ref{expected.relational_op}, Expected relational operators
  template <class T, class E>
    constexpr bool operator==(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator!=(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator<(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator>(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator<=(const expected<E,T>&, const expected<E,T>&);
  template <class T, class E>
    constexpr bool operator>=(const expected<E,T>&, const expected<E,T>&);
    
  // \ref{expected.comparison_T}, Comparison with T
  template <class T, class E> constexpr bool operator==(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator==(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator!=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator!=(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator<(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator<=(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator>(const T&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>=(const expected<E,T>&, const T&);
  template <class T, class E> constexpr bool operator>=(const T&, const expected<E,T>&);

  // \ref{expected.comparison_unexpected_E}, Comparison with unexpected_type<E>
  template <class T, class E> constexpr bool operator==(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator==(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator!=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator!=(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator<(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator<=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator<=(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator>(const unexpected<E>&, const expected<E,T>&);
  template <class T, class E> constexpr bool operator>=(const expected<E,T>&, const unexpected<E>&);
  template <class T, class E> constexpr bool operator>=(const unexpected<E>&, const expected<E,T>&);


  // \ref{expected.specalg}, Specialized algorithms
  template <class T> 
    void swap(expected<E,T>&, expected<E,T>&) noexcept(see below);

  // \ref{expected.factories}, Factories
  template <class T> constexpr expected<exception_ptr, decay_t<T>> make_expected(T&& v);
  template <> expected<exception_ptr, void> make_expected(); 
  template <class E> expected<E,void> make_expected(); 
  
  template <class T>
  expected_type<T> make_expected_from_current_exception();
  template <class T, class E>
   constexpr expected<exception_ptr,T> make_expected_from_exception(E e); 
  template <class T>
   constexpr expected<exception_ptr,T> make_expected_from_exception(std::exception_ptr v);   
 
  template <class T, class E>
   constexpr expected<decay_t<E>,T> make_expected_from_error(E v);

  template <class F>
   constexpr typename expected<exception_ptr, typename result_type<F>::type
   make_expected_from_call(F f);

  // \ref{expected.hash}, hash support
  template <class T> struct hash;
  template <class T> struct hash<expected<E,T>>;
}}}
\end{lstlisting}

A program that necessitates the instantiation of template \cpp{expected<E,T>} with \cpp{T} for a reference type\, or for possibly cv-qualified types \cpp{in_place_t}, \cpp{unexpect_t} or \cpp{unexpected_type<E>} is ill-formed.

\wordingSubSec{Definitions}{expected.defs}
%%%%%%%%%%%%%%%%%%%%%%

An instance of \cpp{expected<E,T>} is said to be valued if it contains an value of type \cpp{T}.
An instance of \cpp{expected<E,T>} is said to be unexpected if it contains an object of type \cpp{E}.

\wordingSubSec{expected for object types}{expected.object}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}

  template <class T, class E>
  class expected
  {
  public:
    typedef T value_type;
    typedef E error_type;
    
    template <class U>
    struct rebind {
      typedef expected<error_type, U> type;
    };
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept(see below);
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    
    constexpr expected(const T&);
    constexpr expected(T&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);     
    template <class U, class... Args>
      constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
      
    constexpr expected(unexpected_type<E> const&);
    template <class Err> 
    constexpr expected(unexpected_type<Err> const&);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    
    template <class U> expected& operator=(U&&);
    
    expected& operator=(const unexpected_type<E>&);
    expected& operator=(unexpected_type<E>&&) noexcept(see below);
    
    template <class... Args> void emplace(Args&&...);
    template <class U, class... Args>
      void emplace(initializer_list<U>, Args&&...);

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr T const* operator ->() const;
    constexpr T* operator ->();
    
    constexpr T const& operator *() const&;
    constexpr T& operator *() &;
    constexpr T&& operator *() &&;
    
    constexpr explicit operator bool() const noexcept;
    
    constexpr T const& value() const&;
    constexpr T& value() &;
    constexpr T&& value() &&;
    
    constexpr E const& error() const&;
    constexpr E& error() &;
    constexpr E&& error() &&;
    
    constexpr unexpected<E>  get_unexpected() const;
    
    template <typename Ex>
    bool has_exception() const;
      
    template <class U> constexpr T value_or(U&&) const&;
    template <class U> T value_or(U&&) &&;
    
    template <class G> constexpr T value_or_throw() const&;
    template <class G> T value_or_throw() &&;

    template constexpr 'see below' unwrap() const&;
    template 'see below' unwrap() &&;

    // \ref{expected.object.factories}, factories

    template <typename Ex, typename F>
    expected<E,T> catch_exception(F&& f);

    template <typename F>
      auto bind(F&& func) const -> expected<E, decltype(func(val))>;
    template <typename F>
      expected<E,T> catch_error(F&& f);
    template <typename F>
      auto then(F&& func) const -> expected<E, decltype(func(*this))>;
  
  private:
    bool has_value;    // exposition only
    union
    {
      value_type val;  // exposition only
      error_type err;  // exposition only
    };
  };

\end{lstlisting}


Valued instances of \cpp{expected<E,T>} where \cpp{T} and \cpp{E} is of object type shall contain a value of type \cpp{T} or a value of type \cpp{E} within its own storage. This value is referred to as the contained or the unexpected value of the expected object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained or unexpected value. The contained or unexpected value shall be allocated in a region of the \cpp{expected<E,T>} storage suitably aligned for the type \cpp{T} and \cpp{E}.
\newline

Members \cpp{has_value}, \cpp{val} and \cpp{err} are provided for exposition only. Implementations need not provide those members. \cpp{has_value} indicates whether the expected object's contained value has been initialized (and not yet destroyed); when \cpp{has_value} is true \cpp{val} points to the contained value, and when it is false \cpp{err} points to the erroneous value. 

\cpp{T} and \cpp{E} shall be an object type and shall satisfy the requirements of \cpp{Destructible}.

\wordingSubSubSec{Constructors}{expected.object.ctor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Default Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected() noexcept(see below);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{T()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the default constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_default_constructible<T>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
 \cpp{is_default_constructible<T>::value}.
\end{wordingTextItem}


\end{wordingPara}

% Copy Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::expected(const expected<E,T>& rhs);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{*rhs}.\\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value} and\\
\cpp{is_copy_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Move Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::expected(expected<E,T> && rhs) noexcept(/*see below*/);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(*rhs)}. \\

\noindent
If \cpp{!bool(rhs)} initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(rhs.error())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)} and \\
\cpp{bool(rhs)} is unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_constructible<T>::value == trye} and   \\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Value Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(const T& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{v}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value}. 
\end{wordingTextItem}
\end{wordingPara}

% Move value constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(T&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class... Args>
constexpr explicit expected(in_place_t, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace constructor with initializer list.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the arguments \cpp{il, std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless:\\
\noindent
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.\\

\noindent
If \cpp{T}'s constructor selected for the initialization is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}


% Unexpected Constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(unexpected_type<E> const& e);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{e.value()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<E>::value}. 
\end{wordingTextItem}
\end{wordingPara}

% Unexpected move constructor
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr expected<E,T>::expected(unexpected_type<E>&& e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Initializes the unexpected value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(e.value())}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{E}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{E}'s selected constructor is a \cpp{constexpr} constructor, this constructor shall be a \cpp{constexpr} constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Destructor}{expected.object.dtor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Destructor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>::~expected();
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{is_trivially_destructible<T>::value != true} and \cpp{bool(*this)}, calls \cpp{val->T::~T()}.\\
If \cpp{is_trivially_destructible<E>::value != true} and \cpp{! *this}, calls \cpp{err->E::~E()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If \cpp{is_trivially_destructible<T>::value} and \cpp{is_trivially_destructible<E>::value} then this destructor shall be a trivial destructor.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Assignment}{expected.object.assign}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Copy assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(const expected<E,T>& rhs); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{bool(rhs)}, assigns \cpp{*rhs} to the contained value \cpp{val}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, assigns \cpp{rhs.error()} to the contained value \cpp{err}, otherwise \\
if \cpp{! *this} and \cpp{bool(rhs)}, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of \cpp{bool(*this)} and \cpp{bool(rhs)} remain unchanged. If an exception is thrown during the call to \cpp{T}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{T}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{T}'s copy assignment. If an exception is thrown during the call to \cpp{E}'s copy constructor, no effect. If an exception is thrown during the call to \cpp{E}'s copy assignment, the state of its contained value is as defined by the exception safety guarantee of \cpp{E}'s copy assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<T>::value} and\\
\cpp{is_copy_assignable<T>::value} and\\
\cpp{is_copy_constructible<E>::value} and\\
\cpp{is_copy_assignable<E>::value}.
\end{wordingTextItem}

\end{wordingPara}

% Move assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(expected<E,T>&& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{rhs} is values, assigns \cpp{std::move(*rhs)} to the contained value \cpp{val}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, destroys the contained value by calling \cpp{val->T::~T()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, assigns \cpp{std::move(rhs.error())} to the contained value \cpp{err}, otherwise  
if \cpp{! *this} and \cpp{bool(rhs)}, destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with \cpp{rhs.error()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_assignable<T>::value &&}\\
\cpp{is_nothrow_move_constructible<T>::value &&}\\
\cpp{is_nothrow_move_assignable<E>::value &&}\\
\cpp{is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, the values of  \cpp{bool(*this)} and \cpp{bool(rhs)} remain unchanged. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{rhs.val} is determined by exception safety guarantee of \cpp{T}'s move constructor. If an exception is thrown during the call to \cpp{T}'s move assignment, the state of \cpp{val} and \cpp{rhs.val} is determined by exception safety guarantee of \cpp{T}'s move assignment. If an exception is thrown during the call to \cpp{E}'s move constructor, the state of \cpp{rhs.err} is determined by exception safety guarantee of \cpp{E}'s move constructor. If an exception is thrown during the call to \cpp{E}'s move assignment, the state of \cpp{err} and \cpp{rhs.err} is determined by exception safety guarantee of \cpp{E}'s move assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_move_assignable<T>::value} and \\
\cpp{is_move_constructible<E>::value} and
\cpp{is_move_assignable<E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Value assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
expected<E,T>& expected<E,T>::operator=(U&& v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{bool(*this)} assigns \cpp{std::forward<U>(v)} to the contained value; otherwise destroys the contained value by calling \cpp{err->E::~E()} and initializes the unexpected value as if direct-non-list-initializing object of type \cpp{T} with \cpp{std::forward<U>(v)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, \cpp{bool(*this)} remains unchanged. If an exception is thrown during the call to \cpp{E}'s constructor, the state of \cpp{e} is determined by exception safety guarantee of \cpp{E}'s constructor. If an exception is thrown during the call to \cpp{E}'s assignment, the state of \cpp{err} and \cpp{e} is determined by exception safety guarantee of \cpp{E}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T,U>::value} and \\
\cpp{is_assignable<T&, U>::value}.
\end{wordingTextItem}
\begin{wordingNoteItem}
The reason to provide such generic assignment and then constraining it so that effectively \cpp{T == U} is to guarantee that assignment of the form \cpp{o = \{\}} is unambiguous.
\end{wordingNoteItem}
\end{wordingPara}

% unexpected assignment operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<E,T>& expected<E,T>::operator=(unexpected_type<E>&& e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
If \cpp{! *this} assigns \cpp{std::forward<E>(e.value())} to the contained value; otherwise destroys the contained value by calling \cpp{val->T::~T()} and initializes the contained value as if direct-non-list-initializing object of type \cpp{E} with \cpp{std::forward<unexpected_type<E>>(e).value()}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{! *this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If any exception is thrown, value of valued remains unchanged. If an exception is thrown during the call to \cpp{T}'s constructor, the state of \cpp{v} is determined by exception safety guarantee of \cpp{T}'s constructor. If an exception is thrown during the call to \cpp{T}'s assignment, the state of \cpp{val} and \cpp{v} is determined by exception safety guarantee of \cpp{T}'s assignment.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_copy_constructible<E>::value} and \\
\cpp{is_assignable<E&, E>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace assignment.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class... Args>
void expected<E,T>::emplace(Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}if \cpp{bool(*this)}, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}, otherwise destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{*this} is disengaged, and the previous \cpp{val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This signature shall not participate in overload resolution unless\\
\cpp{is_constructible<T, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

% Emplace with initializer list assignment.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U, class... Args>
void expected<E,T>::emplace(initializer_list<U> il, Args&&... args); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)}, assigns the contained value \cpp{val} as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}, otherwise 
destroys the contained value by calling \cpp{err->E::~E()} and  initializes the contained value as if constructing an object of type \cpp{T} with the arguments \cpp{il,std::forward<Args>(args)...}.
\end{wordingTextItem}
\begin{wordingTextItem}{Postconditions}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If an exception is thrown during the call to \cpp{T}'s constructor, \cpp{! *this} , and the previous \cpp{val} (if any) has been destroyed.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_constructible<T, initializer_list<U>&, Args&&...>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Swap}{expected.object.swap}
%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap operation.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
void expected<E,T>::swap(expected<E,T>& rhs) noexcept(/*see below*/); 
\end{lstlisting}
\begin{wordingPara}

\begin{wordingTextItem}{Effects}
if \cpp{bool(*this)} and \cpp{bool(rhs)}, calls \cpp{swap(val, rhs.val)}, otherwise \\
if \cpp{! *this} and \cpp{! rhs}, calls \cpp{swap(err, rhs.err)}, otherwise \\
if \cpp{bool(*this)} and \cpp{! rhs}, initializes a temporary variable e by direct-initialization with \cpp{std::move(rhs.err))}, initializes the contained value of \cpp{rhs} by direct-initialization with \cpp{std::move(*(*this))}, initializes the expected value of \cpp{*this} by direct-initialization with \cpp{std::move(rhs.err)} and swaps \cpp{has_value} and \cpp{rhs.has_value}, otherwise \\
calls to \cpp{rhs.swap(*this)};
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
\todo{This must be reworded.}
If any exception is thrown, values of \cpp{has_value} and \cpp{rhs.has_value} remain unchanged. If an exception is thrown during the call to function swap the state of \cpp{val} and \cpp{rhs.val} is determined by the exception safety guarantee of swap for lvalues of \cpp{T}. If an exception is thrown during the call to \cpp{T}'s move constructor, the state of \cpp{val} and \cpp{rhs.val} is determined by the exception safety guarantee of \cpp{T}'s move constructor.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exceptions that the expressions in the Effects clause throw.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to: \\
\cpp{is_nothrow_move_constructible<T>::value && noexcept(swap(declval<T&>(), declval<T&>())) &&} \\
\cpp{is_nothrow_move_constructible<E>::value && noexcept(swap(declval<E&>(), declval<E&>()))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
LValues of type \cpp{T} shall be swappable, \cpp{is_move_constructible<T>::value}, LValues of type \cpp{E} shall be swappable and \cpp{is_move_constructible<T>::value}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSubSec{Observers}{expected.object.observe}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -> operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const* expected<E,T>::operator->() const;
constexpr T* expected<E,T>::operator->(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{&val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
Unless \cpp{T} is a user-defined type with overloaded unary operator\&, the first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% * operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const& expected<E,T>::operator *() const&;
constexpr T& expected<E,T>::operator *() &;
constexpr T&& expected<E,T>::operator *() &&;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{val}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% bool conversion operator.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr explicit expected<E,T>::operator bool() noexcept; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{has_value}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
This function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T const& expected<E,T>::value() const&;
constexpr T& expected<E,T>::value() &;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{val}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access(err)} if \cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% value accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr T&& expected<E,T>::value() &&;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{move(val)}, \cpp{if bool(*this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
\cpp{bad_expected_access(err)} if \cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E const& expected<E,T>::error() const&;
constexpr E& expected<E,T>::error() &; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{err}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E&& expected<E,T>::error() &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{move(err)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

% has_exception accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex>
bool expected<E,T>::has_exception() const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{true} if and only if \cpp{!(*this)} and the stored exception is a base type of \cpp{Ex}.
\end{wordingTextItem}
\end{wordingPara}


% unexpected conversion.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr unexpected<E> expected<E,T>::get_unexpected() const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{!*this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
\cpp{make_unexpected(err)}.
\end{wordingTextItem}
\end{wordingPara}

% value_or method.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
constexpr T expected<E,T>::value_or(U&& v) const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? **this : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class U>
T expected<E,T>::value_or(U&& v) &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v))}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} and \cpp{v} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged and the state of \cpp{v} is determined by the exception safety guarantee of the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% value_or_throw.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class G>
constexpr T expected<E,T>::value_or_throw() const&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{**this}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the selected constructor of \cpp{T}. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! *this} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
If both constructors of \cpp{T} which could be selected are \cpp{constexpr} constructors, this function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% move value_or_throw.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class G>
T expected<E,T>::value_or_throw() &&; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{std::move(**this)}.
\end{wordingTextItem}
\begin{wordingTextItem}{Exception Safety}
If \cpp{has_value} and exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{has_value} remains unchanged and the state of \cpp{val} is determined by the exception safety guarantee of the \cpp{T}'s constructor. Otherwise, when exception is thrown during the call to \cpp{T}'s constructor, the value of \cpp{*this} remains unchanged.
\end{wordingTextItem}
\begin{wordingTextItem}{Throws}
If \cpp{! *this} then \cpp{G(error())}.

\noindent
Any exception thrown by the selected constructor of \cpp{T}.
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<T>::value} and \\
\cpp{is_convertible<U&&, T>::value}.
\end{wordingTextItem}
\end{wordingPara}

% nested copy unwrap.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    template <class E, class U>
    constexpr expected<E,U> expected<E,expected<E,U>>::unwrap() const&;
>::unwrap() &&;
\end{lstlisting}

\begin{wordingPara}

\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{**this}.
else \cpp{get_unexpected()}
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{expected<E,U>}.
\end{wordingTextItem}

\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_copy_constructible<expected<E,T>>::value} \\
\end{wordingTextItem}

\end{wordingPara}

% copy unwrap.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    template <class E, class T>
    constexpr expected<E,T> expected<E,T>::unwrap() const&;
>::unwrap() &&;
\end{lstlisting}

\begin{wordingPara}

\begin{wordingTextItem}{Returns}
\cpp{*this}.
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{expected<E,T>}.
\end{wordingTextItem}

\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{T} is not  \cpp{expected<E,U>}  and \\
\cpp{is_copy_constructible<expected<E,T>>::value} \\
\end{wordingTextItem}

\end{wordingPara}

% nested move unwrap.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    template <class E, class U>
    expected<E,T> expected<E,  expected<E,U>>::unwrap() &&;
>::unwrap() &&;
\end{lstlisting}

\begin{wordingPara}

\begin{wordingTextItem}{Returns}
If \cpp{bool(*this)} then \cpp{std::move(**this)}.
else \cpp{get_unexpected()}
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{expected<E,U>}.
\end{wordingTextItem}

\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<expected<E,U>>::value} \\
\end{wordingTextItem}

\end{wordingPara}

% move unwrap.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
    template <class E, class T>
    template expected<E,T> expected<E,T>::unwrap() &&;
>::unwrap() &&;
\end{lstlisting}

\begin{wordingPara}

\begin{wordingTextItem}{Returns}
\cpp{std::move(**this)}.
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{expected<E,T>}.
\end{wordingTextItem}

\begin{wordingTextItem}{Remarks}
The function shall not participate in overload resolution unless: \\
\cpp{is_move_constructible<expected<E,T>>::value} \\
\end{wordingTextItem}

\end{wordingPara}


\wordingSubSubSec{Factories}{expected.object.factories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% catch_exception factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
expected<E,T> expected<E,T>::catch_exception(F&& func) const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
if \cpp{has_exception<Ex>()} call the continuation function \cpp{fuct} with the stored exception as parameter.
\end{wordingTextItem}
\begin{wordingTextItem}{Returns}
if \cpp{has_exception<Ex>()} returns the result of the call continuation function \cpp{fuct} possibly wrapped on a \cpp{expected<E,T>}, 
otherwise, returns \cpp{*this}.
\end{wordingTextItem}
\end{wordingPara}

% then factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
auto expected<E,T>::then(F&& func) const -> unwrap_nested_expected_t<expected<E, decltype(func(val))>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(*this)))}, 
\end{wordingTextItem}
\end{wordingPara}

% bind factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
auto expected<E,T>::bind(F&& func) const -> unwrap_nested_expected_t<expected<E, decltype(func(val))>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
if \cpp{bool(*this)} returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(**this)))}, 
otherwise, returns \cpp{get_unexpected()}.
\end{wordingTextItem}
\end{wordingPara}

% catch_error factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class Ex,class F>
expected<E,T> expected<E,T>::catch_error(F&& func) const;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
if \cpp{! (*this)} returns \cpp{unwrap(expected<E, decltype(func(val))>(funct(**this)))}, 
if \cpp{! *this} returns the result of the call continuation function \cpp{fuct} possibly wrapped on a \cpp{expected<E,T>}, 
otherwise, returns \cpp{*this}.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{\cpp{expected} as a meta-fuction}{expected.object.meta}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
  template <class E>
  class expected<E, holder>
  public:
    template <class T>
    using type = expected<E,T>
  };
\end{lstlisting}

\wordingSubSec{expected for void}{expected.object.void}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
  template <class E>
  class expected<E, void>
  {
  public:
    typedef void value_type;
    typedef E error_type;
    
    template <class U>
    struct rebind {
      typedef expected<error_type, U> type;
    };
    
     // \ref{expected.object.void.ctor}, constructors
    constexpr expected() noexcept;
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr explicit expected(in_place_t);     
      
    constexpr expected(unexpected_type<E> const&);
    template <class Err> 
    constexpr expected(unexpected_type<Err> const&);

    // \ref{expected.object.void.dtor}, destructor
    ~expected();

    // \ref{expected.object.void.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    void emplace();

    // \ref{expected.object.void.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.void.observe}, observers
    constexpr explicit operator bool() const noexcept;
    void value() const;
    constexpr E const& error() const&;
    constexpr E& error() &;
    constexpr E&& error() &&;
    constexpr unexpected<E>  get_unexpected() const;
    
    template <typename Ex>
    bool has_exception() const;
    
    template constexpr 'see below' unwrap() const&;
    template 'see below' unwrap() &&;

    // \ref{expected.object.void.factories}, factories


    template <typename Ex, typename F>
    expected<E,void> catch_exception(F&& f);

    template <typename F>
      auto bind(F&& func) const -> expected<E, decltype(func())>;
    template <typename F>
      expected<void,E> catch_error(F&& f);
    template <typename F>
      auto then(F&& func) const -> expected<E, decltype(func(*this))>;

  private:
    bool has_value;    // exposition only
    union
    {
      unsigned char dummy;  // exposition only
      error_type err;  // exposition only
    };
  };

\end{lstlisting}

\todo{Describe the functions.}



\wordingSubSec{unexpect tag}{expected.unexpect}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unexpect tag
\begin{lstlisting}
struct unexpet_t{};
constexpr unexpet_t unexpet{};
\end{lstlisting}
\noindent


\wordingSubSec{Template Class bad_expected_access}{expected.bad_expected_access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
  template <class E>
  class bad_expected_access : public logic_error {
  public:
    explicit bad_expected_access(E);
    constexpr error_type const& error() const;
    error_type& error();
  };
}
\end{lstlisting}

The template class \cpp{bad_expected_access} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a unexpected expected object.

% constructor with string message.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
bad_expected_access::bad_expected_access(E e); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
Constructs an object of class \cpp{bad_expected_access} storing the parameter.
\end{wordingTextItem}
\end{wordingPara}

% error accessor.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
constexpr E const& bad_expected_access::error() const; 
E& bad_expected_access::error(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
The stored error..
\end{wordingTextItem}
\begin{wordingTextItem}{Remarks}
The first function shall be a \cpp{constexpr} function.
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Class expected_default_constructed}{expected.expected_default_constructed}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}
namespace std {
  template <class E>
  class expected_default_constructed : public logic_error {
  public:
    explicit expected_default_constructed();
  };
}
\end{lstlisting}

The class \cpp{expected_default_constructed} defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the \cpp{expected<exception_ptr,T>::error()}/\cpp{expected<exception_ptr,T>::get_unexpected()} value of a unexpected expected object that has no exception stored.

\todo{Describe the functions.}

\wordingSubSec{Expected Relational operators}{expected.relational_op}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Comparison with \cpp{T}}{expected.comparison_T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Comparison with \cpp{unexpected<E>}}{expected.comparison_unexpected_E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Describe the functions.}

\wordingSubSec{Specialized algorithms}{expected.specalg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% swap free function.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
void swap(expected<E,T>& x, expected<E,T>& y) noexcept(noexcept(x.swap(y))); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Effects}
calls \cpp{x.swap(y)}.
\end{wordingTextItem}
\end{wordingPara}


\wordingSubSec{Expected Factories}{expected.factories}

% make_expected move value factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
constexpr expected<exception_ptr, typename decay<T>::type> make_expected(T&& v);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr, typename decay<T>::type>(std::forward<T>(v))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
expected<exception_ptr, void> make_expected(); 
template <class E>
expected<E, void> make_expected(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<E,void>(in_place)}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
expected<exception_ptr,T> make_expected_from_exception(std::exception_ptr v); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr,T>(unexpected_type<E>(std::forward<E>(v)))}.
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_error factory.
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
constexpr expected<decay_t<E>,T> make_expected_from_error(E e);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<decay_t<E>,T>(make_unexpected(e));}
\end{wordingTextItem}
\end{wordingPara}


% make_expected_from_error factory (flying exception).
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T>
constexpr expected<exception_ptr,T> make_expected_from_current_exception(); 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Returns}
\cpp{expected<exception_ptr,T>(make_unexpected_from_current_exception())}
\end{wordingTextItem}
\end{wordingPara}

% make_expected_from_call
\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class F>
constexpr typename expected<exception_ptr, result_of<F()>::type make_expected_from_call(F funct);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Equivalent to}
\begin{lstlisting}[language=C++][xleftmargin=0pt]
  try
  {
    return make_expected(funct());
  }
  catch (...)
  {
    return make_unexpected_from_current_exception();
  }
\end{lstlisting}
\end{wordingTextItem}
\end{wordingPara}

\wordingSubSec{Hash support}{expected.hash}

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class T, class E>
struct hash<expected<E,T>>; 
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\todo{This must be reworded}

The template specilaization \cpp{hash<T>} and \cpp{hash<E>} shall meet the requirements of class template \cpp{hash} (Z.X.Y). The template specialization \cpp{hash<expected<E,T>>} shall meet the requirements of class template \cpp{hash}. For an object \cpp{o} of type \cpp{expected<E,T>}, \cpp{if bool(o)}, \cpp{hash<expected<E,T>>()(o)} shall evaluate to the same value as \cpp{hash<T, E>()(*o);} otherwise it evaluates to an unspecified value.
\end{wordingTextItem}
\end{wordingPara}

\begin{lstlisting}[language=C++][xleftmargin=0pt]
template <class E>
struct hash<expected<E, void>>;
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\end{wordingTextItem}
\end{wordingPara}

\section{Implementability}
This proposal can be implemented as pure library extension, without any compiler magic support, in C++14. An almost full reference implementation of this proposal can be found at TBoost.Expected \cite{boost.expected}. 
\section{Acknowledgement}

We are very grateful to Andrei Alexandrescu for his talk, which was the origin of this work.
We thanks also to every one that has contributed to the Haskell either monad, as either's interface was a source of inspiration.
Thanks to Fernando Cacciola, Andrzej KrzemieÅ„ski and every one that has contributed to the wording and the rationale of N3793 \cite{OptionalRev5}.

Vicente thanks personnaly Evgeny Panasyuk and Johannes Kapfhammer for their remarks on the DO-expression. 

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}