\documentclass[a4paper,10pt]{article}
\usepackage[american]
           {babel} % needed for iso dates
\usepackage{url}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{array}
\usepackage{underscore}
\usepackage{changepage}   % for the adjustwidth environment

\hypersetup{
  hidelinks
}

\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{color}
\usepackage{textpos}
\usepackage{titling}
\usepackage{titlesec}

\setcounter{secnumdepth}{6}

% From std draft
% We use the 'listings' package, with some small customizations.  The
% most interesting customization: all TeX commands are available
% within comments.  Comments are set in italics, keywords and strings
% don't get special treatment.
% General code style
\lstset{language=C++,
        basicstyle=\small\ttfamily,
        keywordstyle=,
        stringstyle=,
        xleftmargin=1em,
        showstringspaces=false,
        commentstyle=\itshape\rmfamily,
        columns=flexible,
        keepspaces=true,
        texcl=true
}
% end from std draft

\newcommand{\wordingSec}[2]{\vspace{15pt}
\noindent
{\large\textbf{X.Y\quad #1\hfill\textbf{[#2]}}}
}

% Counters
\newcounter{countWordingSubSec}
\newcounter{countWordingSubSubSec}[countWordingSubSec]

\renewcommand{\thecountWordingSubSec}{X.Y.\arabic{countWordingSubSec}}
\renewcommand{\thecountWordingSubSubSec}{X.Y.\arabic{countWordingSubSec}.\arabic{countWordingSubSubSec}}

% Defs of sub and subsub section (for the wording).
\newcommand{\wordingSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSec}
\noindent
{\textbf{\thecountWordingSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\wordingSubSubSec}[2]{\vspace{15pt}
\refstepcounter{countWordingSubSubSec}
\noindent
{\textbf{\thecountWordingSubSubSec\quad #1\hfill\textbf{[#2]}}}
\label{#2}
\vspace{7pt}
}

\newcommand{\cpp}[1]{\lstinline{#1}}

% Wording items
\newcommand{\wordingItem}[1]{\noindent\textit{#1:}}

\newenvironment{wordingTextItem}[1]{\wordingItem{#1}\vspace{7pt}\noindent\begin{adjustwidth}{12pt}{}}{\vspace{7pt}\end{adjustwidth}}

\newenvironment{wordingPara}{\begin{adjustwidth}{12pt}{}}{\end{adjustwidth}}

\lstset{
  xleftmargin=12pt
}

\setlength{\droptitle}{10em}
\title{A proposal to add a utility class to represent expected objects}
\author{}
\date{}

\begin{document}

\maketitle
\begin{textblock*}{9cm}(7cm,-8cm)
\begin{tabular}{l l}
\textbf{Document number:} & Dxxxx=xx-xxxx \\
\textbf{Date:}  & \today \\
\textbf{Revises:} & None \\
\textbf{Project:} & JTC1.22.32 Programming \\
 & Language C++ \\
\textbf{Reply to:} & Vicente J. Botet Escriba \\
 & <\href{mailto:vicente.botet@wanadoo.fr}{vicente.botet@wanadoo.fr}> \\
 & Pierre Talbot <\href{mailto:ptalbot@hyc.io}{ptalbot@hyc.io}>
\end{tabular}
\end{textblock*}

\vspace{-6em}
\setcounter{tocdepth}{1}
\tableofcontents

\section{Introduction}

Class template \cpp{expected<T,E>} proposed here is a type that may contain a value of type \cpp{T} or a value of type \cpp{E} in its storage space. \cpp{T} represents the expected value, \cpp{E} represents the exceptional reason why it doesn't contains a value of type \cpp{T}. Its interface allows to query if the underlying value is either the expected value (of type \cpp{T}) or an error value (of type \cpp{E}). The original idea comes from Andrei Alexandrescu C++ and Beyond 2012: Systematic Error Handling in C++ talk \cite{AlexandrescuExpected}. The interface is based on \cpp{std::optional} N3793 \cite{OptionalRev5} and Haskell monad either. It requires no changes to core language, and breaks no existing code.

\section{Motivation and Scope}

Basically, the two main error mechanisms are exceptions and return codes. Before further explanation, we should ask us what are the characteristics of a good error mechanism.

\begin{itemize}
 \item \textbf{Error visibility} Failure cases should appears throughout the code review. Because the debug can be painful if the errors are hidden.
 \item \textbf{Information on errors} The errors should carry out as most as possible information from their origin, causes and possibly the ways to resolve it.
 \item \textbf{Clean code} The treatment of errors should be in a separate layer of code and as much invisible as possible. So the code reader could notice the presence of exceptional cases without stop his reading.
 \item \textbf{Intrusive error} The errors should not monopolize a communication channel dedicated to the normal code flow. They must be as discrete as possible. For instance, the return of a function is a channel that should not be exclusively reserved for errors.
\end{itemize}

The first and the third characteristic are quite contradictory. The former points out that errors not handled should appear clearly in the code. The latter tells us that the error handling mustn't interfere with the code reading, meaning that it clearly shows the normal execution flow. A comparison between the exception and return codes is given in the table \ref{comp-handling-error}.


\begin{table}
\bgroup
\def\arraystretch{1.5}
\begin{tabular}{|l|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
\hline
                    & \textbf{Exception} & \textbf{Return code} \\
\hline
\textbf{Visibility} & Not visible without further analysis of the code. However, if an exception is thrown, we can follow the stack trace. & Visible at the first sight by watching the prototype of the called function. However ignoring return code can lead to undefined results and it can be hard to figure out the problem. \\
\hline
\textbf{Informations} & Exceptions can be arbitrarily rich. & Historically a simple integer. Nowadays, the header \cpp{<system_error>} provides richer error code. \\
\hline
\textbf{Clean code} & Provides clean code, exceptions can be completely invisible for the caller. & Force you to add, at least, a if statement after each function call. \\
\hline
\textbf{Intrusive} & Proper communication channel. & Monopolization of the return channel. \\
\hline
\end{tabular}
\egroup
\caption{Comparison between two error handling systems.}
\label{comp-handling-error}
\end{table}

\section{Alexandrescu Expected class}

We can do the same analysis for the \cpp{Expected<T>} class from Alexandrescu talk \cite{AlexandrescuExpected}:

\begin{itemize}
 \item \textbf{Error visibility} It takes the best of the exception and error code. It's visible because the return type is Expected<T> and if the user ignore the error case, it throws the contained exception.
 \item \textbf{Information} As rich as exception.
 \item \textbf{Clean code} It's up to the programmer to choose handling errors as error code or to throw the contained exception.
 \item \textbf{Intrusive} Use the return channel without monopolizing it.
\end{itemize}

\noindent
Other characteristics of \cpp{Expected<T>}:

\begin{itemize}
 \item Associates errors with computational goals.
 \item Naturally allows multiple exceptions inflight.
 \item Switch between ``error handling'' and ``exception throwing'' styles.
 \item Teleportation possible.
 \begin{itemize}
  \item Across thread boundaries.
  \item Across nothrow subsystem boundaries.
  \item Across time: save now, throw later.
 \end{itemize}
 \item Collect, group, combine exceptions.
\end{itemize}

\noindent
However \cpp{Expected<T>} class also has some drawbacks:
\begin{itemize}
 \item The error code must be an exception.
 \item It doesn't provide a better solution to resolve errors. You can throw or use the \cpp{hasException<E>()} function to test errors which is similar to the old switch case statement.
 \item The function \cpp{hasException<E>()} test the type and so cannot distinguish two different errors from the same exception. Exception can contains multiple error case scenarios (think about \cpp{std::invalid_argument}).
\end{itemize}

\noindent
The main enhancements or differences of the proposed \cpp{expected<T,E>} respect to \cpp{Expected<T>} are:
\begin{itemize}
 \item \cpp{expected<T,E>} is default constructible.
 \item \cpp{expected<T,E>} parameterizes the root cause that prevents its creation, \cpp{expected<T,E>} is either a \cpp{T} or the root cause \cpp{E} that prevents its creation. The default type \cpp{E} would be \cpp{std::exception_ptr} as the exceptions seem to be the most used error-handling system. There is also some supports for the classes in the \cpp{<system_error>} header.
 \item \cpp{expected<T,E>} is a monad.
\end{itemize}

\section{Use case scenario}

We should wonder what every programmers do when a function call returns an error:

\begin{enumerate}
 \item Nothing.
 \item Delegate the responsibility of error handling to higher layer.
 \item Trying to resolve the error.
\end{enumerate}

Because the first behavior leads to buggy application, we won't consider it in a first time. Consider the following ``pseudo coded'' mock function:

\begin{lstlisting}
EXPECTED int mock_connect(const string& hostname, const string& passwd, bool timed_out){
  if(passwd != "passwd")
      return connection refused ERROR
  else if(hostname != "localhost")
      return host unreachable ERROR
  else if(timed_out)
      return timed out ERROR
  return HANDLE 0
}
\end{lstlisting}

We imagine a scenario where:

\begin{itemize}
 \item The \textit{connection refused} error is resolved by asking the user another password.
 \item The \textit{host unreachable} error is delegated to the upper layer.
 \item The \textit{time out} error is resolved at the next try.
\end{itemize}

\subsection{Exception-based expected}

The code of the mock connect function is below. You can see that the errors are encapsulated into exceptions.
TODO INSERT CODE
From the caller, the code looks like:
TODO INSERT CODE
Moreover, we use an error resolver function to keep the code as clean as possible.
TODO INSERT CODE
The next section shows how to do the same things with the standard error code (\cpp{std::error_condition}).

\subsection{Error-based expected}

We use the class \cpp{expected_or_error} which looks like the class expected without the exception.
TODO INSERT CODE
From the caller, the code looks like:
TODO INSERT CODE
And finally the error resolver:
TODO INSERT CODE
We can see that the code is quite similar between both classes. It's mainly because we didn't use the exception facility of the expected class.

\subsection{Result}

The result of the both codes is the same TODO INSERT CODE

\section{Impacts on the Standard}

These changes are entirely based on library extensions and do not require any language features beyond what is available in C++ 14. It requires however the \cpp{in_place_t} from N.

\section{Design rationale}

\subsection{\cpp{expected<>} is not always default constructible}
\cpp{expected<T,E>} is intended to be used as result type of a function. Providing default constructor would allow to write code

\begin{lstlisting}
expected<T,E> e;
e = f(...);
\end{lstlisting}

but this would need to add an additional init bool member. If the user wants he would use a combination of optional and expected:

\begin{lstlisting}
optional<expected<T,E>> oe;
oe = f(...);
\end{lstlisting}

\subsection{Making \cpp{expected<T,E>} default constructible}

It is possible to make it default constructible adding an additional init bool member. \\
It is possible to make it default constructible by default constructing to the default constructor of E. So if  E is default constructible, as it is the case of \cpp{std::exception_ptr} and \cpp{std::error_condition}, \cpp{expected<T,E>} is default constructible.

\subsection{About \cpp{nullexpected}}
While \cpp{expected<int,std::exception_ptr>} has a natural default constructor, \cpp{expected<int, std::exception_ptr> ei;}
and can be disengaged assigning \cpp{std::exception_ptr()}, it is less obvious how to disengage a \cpp{expected<int, std::condition_error>}. For this it could be more natural to make use of \cpp{nullexpected}.

\begin{lstlisting}
expected<int, std::condition_error> ei;

ei =  std::nullexpected;
\end{lstlisting}

\section{Related work}

\subsection{Either monad and Variant}

\cpp{expected<T,E>} can be seen as a specialization of a possible \cpp{either<T,E>} or \cpp{boost::variant<T,E>} which gives a specific intent to its first parameter, that is, it represent the type of the expected contained value. This specificity allows to provide a pointer like interface, as it is the case for \cpp{expected<T, E>}. Even if the standard contained a class \cpp{either<T,E>} or \cpp{variant<T,E>}, the interface provided by expected<T,E> is more specific and closer to what the user could expect as the result type of a function. In addition, \cpp{expected<T,E>} doesn't intend to be used to define recursive data as \cpp{boost::variant} does.

\subsection{Optional}

We can see \cpp{expected<T,E>} as an optional that collapse all the values of \cpp{E} to \cpp{nullopt}. We can convert an \cpp{expected<T, E>} to an \cpp{optional<T>} with the possible loss of information.

\begin{lstlisting}
template <class T>
optional<T> optional_cast(expected<T,E>);
\end{lstlisting}

We can convert an \cpp{optional<T>} to an \cpp{expected<T>} with the possible loss of the cause.

\begin{lstlisting}
template <class T>
expected<T> expected_cast(optional<T>);
\end{lstlisting}

\subsection{Promise and Future}

We can see \cpp{expected<T,std::exception_ptr>} as an immediate \cpp{future<T>}.
While promise/future focuses on inter-thread asynchronous communication, excepted focus on eager and synchronous computations.
We can move \cpp{future<T>} to an \cpp{expected<T, std::exception_ptr>} with no loss of information. At the end, the underlying type of \cpp{future<T>} could be \cpp{expected<T, std::exception_ptr>}.

\begin{lstlisting}
template <class T>
expected<T> expected_cast(future<T>&&);
\end{lstlisting}

\subsection{Expected monad}

As for the \cpp{future<T>} proposal, \cpp{expected<T,E>} provides also a way to visit the stored values.
\cpp{future<T>} provides a \cpp{then()} function that accepts a continuation having the \cpp{future<T>} as parameter. The synchronous nature of expected makes it more appropriated to use two functions, one to manage with the case expected has a value and one to try to recover otherwise. This is more in line with the monad interface, as any function having a T as parameter can be used as parameter of the apply function, no need to have a \cpp{expected<T>}. This make it easier to reuse functions. 

\begin{itemize}
 \item .apply/.recover are the counterpart of \cpp{future<T>.then()}
 \item .unwrap is the counterpart of \cpp{future<T>.unwrap()}
 \item .valid is the counterpart of \cpp{future<T>.is_ready()}
 \item \cpp{if_all} and \cpp{if_any} are the counterpart of \cpp{when_all()} and \cpp{when_any()}
\end{itemize}

\section{Proposed Wording}

The proposed changes have been modified to be expressed as edits to N3797, the C++ Draft Standard \cite{Cppdraft}. The wording has been adapted from N3797 \cite{OptionalRev5}.
\newline

Insert a new paragraph.

\wordingSec{Expected library}{expected}

\wordingSubSec{In general}{expected.general}

This subclause describes class template expected that represents expected objects. An expected object for object type T is an object that contains the storage for another object and manages the lifetime of this contained object T, alternatively it could contain the storage for another exceptional object E. The contained object may not be initialized after the expected object has been initialized, and may not be destroyed before the expected object has been destroyed. The initialization state of the contained object is tracked by the expected object.

\wordingSubSec{Header <experimental/expected> synopsis}{expected.synop}

\begin{lstlisting}
namespace std {namespace experimental {

  // \ref{expected.object}, expected for object types  
  template <class T, class E = exception_ptr>
  class expected;
  template <class E>
  class expected<void, E>;
  
  // \ref{expected.exceptional}, exceptional construction
  struct exceptional_t{};
  constexpr exceptional_t exceptional{};
  
  // \ref{expected.unitialized}, class expected_unitialized 
  class expected_unitialized;
  
  // \ref{expected.bad_expected_access}, class bad_expected_access
  class bad_expected_access;
  
  // \ref{expected.relational_op}, Relational operators
  template <class T>
    constexpr bool operator==(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator!=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator<=(const expected<T, E>&, const expected<T, E>&);
  template <class T>
    constexpr bool operator>=(const expected<T, E>&, const expected<T, E>&);
    
  // \ref{expected.comparison_T}, Comparison with T
  template <class T> constexpr bool operator==(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator==(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator!=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator!=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator<=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator<=(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>(const T&, const expected<T, E>&);
  template <class T> constexpr bool operator>=(const expected<T, E>&, const T&);
  template <class T> constexpr bool operator>=(const T&, const expected<T, E>&);

  // \ref{expected.specalg}, Specialized algorithms
  template <class T> 
    void swap(expected<T, E>&, expected<T, E>&) noexcept(see below);

  // \ref{expected.factories}, Factories
  template <class T>
    constexpr expected<typename decay<T>::type> make_expected(T&& v); 
  template <class T> constexpr expected<see below> make_expected(T&&);
  template <> constexpr expected<void> make_expected(); 
  template <class T>
   constexpr expected<T> make_expected_from_exception(std::exception_ptr v); 
  template <class T, class E>
   constexpr expected<T> make_expected_from_exception(E&& v);
  template <class T>
   constexpr expected<T> make_expected_from_exception(); 
  template <class F>
   constexpr typename expected<typename result_type<F>::type
   make_expected_from_call(F f);

  // \ref{expected.hash}, hash support
  template <class T> struct hash;
  template <class T> struct hash<expected<T, E>>;
}}
\end{lstlisting}

\wordingSubSec{Definitions}{expected.defs}

An instance of \cpp{expected<T,E>} is said to be valued if it contains an object of type \cpp{T}.
An instance of \cpp{expected<T,E>} is said to be exceptional if it contains an object of type \cpp{E}.

\wordingSubSec{expected for object types}{expected.object}

\begin{lstlisting}
namespace std {
namespace experimental {

  template <class T, class E>
  class expected
  {
  public:
    typedef T value_type;
    typedef E exceptional_type;
    
     // \ref{expected.object.ctor}, constructors
    constexpr expected() noexcept;
    //constexpr expected() = delete;
    expected(const expected&);
    expected(expected&&) noexcept(see below);
    constexpr expected(const T&);
    constexpr expected(T&&);
    template <class... Args> 
      constexpr explicit expected(in_place_t, Args&&...);
    template <class U, class... Args>
      constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
    constexpr expected(exceptional_t, const E&);
    constexpr expected(exceptional_t, E&&);
    template <class... Args> 
      constexpr explicit expected(exceptional_t, in_place_t, Args&&...);
    template <class U, class... Args>
      constexpr explicit expected(exceptional_t, in_place_t,
                                  initializer_list<U>, Args&&...);

    // \ref{expected.object.dtor}, destructor
    ~expected();

    // \ref{expected.object.assign}, assignment
    expected& operator=(const expected&);
    expected& operator=(expected&&) noexcept(see below);
    template <class U> expected& operator=(U&&);
    template <class... Args> void emplace(Args&&...);
    template <class U, class... Args>
      void emplace(initializer_list<U>, Args&&...);

    // \ref{expected.object.swap}, swap
    void swap(expected&) noexcept(see below);

    // \ref{expected.object.observe}, observers
    constexpr T const* operator ->() const;
    T* operator ->();
    constexpr T const& operator *() const;
    T& operator *();
    constexpr explicit operator bool() const noexcept;
    constexpr T const& value() const;
    T& value();
    constexpr E const& error() const;
    E& error();
    template <class U> constexpr T value_or(U&&) const&;
    template <class U> T value_or(U&&) &&;

  private:
    bool valued; // exposition only
    T*   val;    // exposition only
    T*   error;  // exposition only
  };

} // namespace experimental
} // namespace std
\end{lstlisting}


Valued instances of \cpp{expected<T, E>} where T is of object type shall contain a value of type \cpp{T} within its own storage. This value is referred to as the contained value of the expected object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a region of the \cpp{expected<T, E>} storage suitably aligned for the type T.
\newline

Members valued, val and except are provided for exposition only. Implementations need not provide those members. valued indicates whether the expected object's contained value has been initialized (and not yet destroyed); when valued is true val point to the contained value, and when it is false expect point to the exceptional value. \cpp{T} shall be an object type and shall satisfy the requirements of \cpp{Destructible} (Table 24).

\wordingSubSubSec{Constructors}{expected.object.ctor}

\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(const expected<T, E>& rhs);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires} \cpp{is_copy_constructible<T>::value == true} and\\
\cpp{is_copy_constructible<E>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
If \cpp{rhs} is valued initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{*rhs}.\\

\noindent
If \cpp{rhs} is exceptional initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{rhs.error()}.
\end{wordingTextItem}

\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}
\end{wordingPara}

\begin{lstlisting}[xleftmargin=0pt]
expected<T, E>::expected(expected<T, E> && rhs) noexcept(/*see below*/);
\end{lstlisting}
\begin{wordingPara}
\begin{wordingTextItem}{Requires}
\cpp{is_move_constructible<T>::value == true} and \\
\cpp{is_move_constructible<T>::value == true}.
\end{wordingTextItem}
\begin{wordingTextItem}{Effects}
If \cpp{rhs} is valued initializes the contained value as if direct-non-list-initializing an object of type \cpp{T} with the expression \cpp{std::move(*rhs)}. \cpp{bool(rhs)} is unchanged.\\

\noindent
If \cpp{rhs} is exceptional initializes the contained value as if direct-non-list-initializing an object of type \cpp{E} with the expression \cpp{std::move(rhs.error())}. \cpp{bool(rhs)} is unchanged.
\end{wordingTextItem}

\begin{wordingTextItem}{Postconditions}
\cpp{bool(rhs) == bool(*this)}.
\end{wordingTextItem}

\begin{wordingTextItem}{Throws}
Any exception thrown by the selected constructor of \cpp{T} or \cpp{E}.
\end{wordingTextItem}

\begin{wordingTextItem}{Remarks}
The expression inside \cpp{noexcept} is equivalent to:\\
\cpp{is_nothrow_move_constructible<T>::value && is_nothrow_move_constructible<E>::value}.
\end{wordingTextItem}
\end{wordingPara}


\wordingSubSubSec{Destructor}{expected.object.dtor}

\wordingSubSubSec{Assignment}{expected.object.assign}

\wordingSubSubSec{Swap}{expected.object.swap}

\wordingSubSubSec{Observers}{expected.object.observe}

\wordingSubSec{Exceptional construction}{expected.exceptional}

\begin{lstlisting}
struct exceptional_t{}; 
constexpr exceptional_t exceptional{};
\end{lstlisting}
\noindent
The \cpp{struct exceptional_t} is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, \cpp{expected<T, E>} has a constructor with \cpp{exceptional_t} as the first argument followed by an E; this indicates that \cpp{expected<T, E>} should be constructed as exceptional. 

\wordingSubSec{Class unitialized_expected}{expected.unitialized}

\wordingSubSec{Class bad_expected_access}{expected.bad_expected_access}

\wordingSubSec{Relational operators}{expected.relational_op}

\wordingSubSec{Comparison with T}{expected.comparison_T}

\wordingSubSec{Specialized algorithms}{expected.specalg}

\wordingSubSec{Factories}{expected.factories}

\wordingSubSec{Hash support}{expected.hash}

\section{Implementability}
This proposal can be implemented as pure library extension, without any compiler magic support, in C++14. An almost full reference implementation of this proposal can be found at TBoost.Expected \cite{boost.expected}. 
\section{Acknowledgement}

We are very grateful to Andrei Alexandrescu for his talk, which was the origin of this work.
We thanks also to every one that has contributed to the Haskell either monad, as either's interface was a source of inspiration.
Thanks to Fernando Cacciola, Andrzej Krzemieński and every one that has contributed to the wording of N3793 \cite{OptionalRev5}.

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}